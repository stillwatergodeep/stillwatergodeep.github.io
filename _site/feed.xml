<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>stillwater</title>
    <description>Hello, My Name is stillwater, I'm a software Engineer and Web Developer from China. </description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 13 Feb 2017 01:31:14 +0800</pubDate>
    <lastBuildDate>Mon, 13 Feb 2017 01:31:14 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Velocity源码阅读(转)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Velocity 是一个基于Java的模板引擎。它高效、简洁，且有很好的可扩展性，适合在Web项目中做为MVC模型中的视图，也可以在内容生成、数据转换等应用中独立使用。本文将以源码阅读的方式，浅析velocity的实现机制，并通过几个小例子来阐述velocity中主要使用的技术点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;1下载源码&quot;&gt;1.下载源码&lt;/h3&gt;

&lt;p&gt;Velocity是Apache的顶级项目。可以从 http://velocity.apache.org/ 上获取最新源码，最新版本是1.7。为了契合日常的工作，这里使用1.6.3版本做为本文基准版本，可以从 http://archive.apache.org/dist/velocity/engine/ 获取Older releases版本。&lt;/p&gt;

&lt;p&gt;下载：http://archive.apache.org/dist/velocity/engine/1.6.3/velocity-1.6.3.tar.gz&lt;/p&gt;

&lt;p&gt;原始的velocity使用ant构建工程，如果要使用maven可以单独下载对应的pom文件，重命名后放入工程目录。 http://archive.apache.org/dist/velocity/engine/1.6.3/velocity-1.6.3.pom&lt;/p&gt;

&lt;p&gt;下载完成后，解压，放入pom.xml，然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;mvn eclipse:eclipse -DdownloadSources=true&lt;/code&gt;，可以愉快的看源码了~&lt;/p&gt;

&lt;h3 id=&quot;2代码结构&quot;&gt;2.代码结构&lt;/h3&gt;

&lt;p&gt;看代码前，先来了解一下velocity的工程目录结构：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;目录&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;build/&lt;/td&gt;
      &lt;td&gt;存放一些ant构建脚本，比如可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ant javadocs&lt;/code&gt;生成javadoc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;convert/&lt;/td&gt;
      &lt;td&gt;WebMacro到Velocity的转换程序，WebMacro是老牌模板引擎，Velocity脱胎于它，参见 http://velocity.apache.org/engine/releases/velocity-1.4/differences.html 了解它们的不同。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docs/&lt;/td&gt;
      &lt;td&gt;Velocity开发文档，快速指南等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docs/api/&lt;/td&gt;
      &lt;td&gt;Velocity Javadocs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;examples/&lt;/td&gt;
      &lt;td&gt;如何使用Velocity的几个例子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lib/&lt;/td&gt;
      &lt;td&gt;velocity依赖的包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lib/test/&lt;/td&gt;
      &lt;td&gt;单元测试依赖的包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;src/&lt;/td&gt;
      &lt;td&gt;源码包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test/&lt;/td&gt;
      &lt;td&gt;单测&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xdocs/&lt;/td&gt;
      &lt;td&gt;从xml构建docs站点的源文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LICENSE&lt;/td&gt;
      &lt;td&gt;Apache License Version 2.0 ，可作为开源或商业软件再发布&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;velocity-1.6.3.jar&lt;/td&gt;
      &lt;td&gt;velocity jar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;velocity-1.6.3-dep.jar&lt;/td&gt;
      &lt;td&gt;velocity 将依赖打入的standalone jar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;21hello-world-&quot;&gt;2.1.Hello World !&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在开始Hello World前，可以思考一下，如果是自己来设计一个模板引擎需要哪些步骤？&lt;/p&gt;

  &lt;p&gt;嗯，应该需要一个上下文变量Context，用于存放一些会渲染到模板中的变量；然后通过文件或是常量字符串来获取模板；模板里面掏几个占位符，用一些特殊的标记隔离出来(比如#name#)；最后解析模板中的占位符，将Context中的变量的实际值替换进去，然后输出merge后的结果完成模板渲染。(之前自定义短信模板这么做的，很轻巧；邮件内容较多，则使用velocity。)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;思考过后，我们来run一个examples目录下的例子，找到应用程序的入口点，然后进行代码阅读，看看跟我们想的是否一样。 将examples/下的第一个例子app_example1/的样例文件(主要是Example.java、example.vm、velocity.properties)copy到src里。&lt;/p&gt;

&lt;p&gt;Example&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;templateFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/*
             * Velocity的初始化可以使用Velocity类通过RuntimeSingleton类的单例模式初始化，或者使用
             * VelocityEngine类创建并初始化。两者用在不同的场景。
             */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Velocity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;velocity.properties&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/*
             * 构建模板上下文，放入一些将会渲染的变量。
             */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;VelocityContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VelocityContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/*
             * 从文件获取模板：此过程会在调用Template.process()过程中生成抽象语法树AST。这个貌似比想象的要复杂一点，
             * 稍后来讨论AST相关内容。
             */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Template&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Velocity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;templateFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResourceNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rnfe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Example : error : cannot find template &quot;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;templateFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ParseErrorException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Example : Syntax error in template &quot;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;templateFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/*
             * 模板执行merge动作，将context的变量替换到template中，此过程使用到java的Introspection机制，实现了一套反射功能。
             */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BufferedWriter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OutputStreamWriter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/*
             * flush and cleanup，放finally比较好，虽然只是测试代码
             */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过阅读和执行Example例子，我们看到velocity运转时的几个关键步骤：&lt;/p&gt;

&lt;p&gt;1.引擎初始化。&lt;/p&gt;

&lt;p&gt;2.获取模板文件并解析生成AST。&lt;/p&gt;

&lt;p&gt;3.构建context并将其merge到模板中输出。&lt;/p&gt;

&lt;p&gt;接下来将就这三个重要步骤做进一步的阅读和分析。&lt;/p&gt;

&lt;h3 id=&quot;3初始化过程&quot;&gt;3.初始化过程&lt;/h3&gt;

&lt;p&gt;RuntimeInstance.init()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public synchronized void init() throws Exception {
        ...
                // 初始化配置，先读org/apache/velocity/runtime/defaults/velocity.properties，然后再合并应用特殊配置。
                initializeProperties();

                // 初始化日志，可通过properties文件配置使用何种日志组件。
                initializeLog();

                // 初始化资源管理类，对模板资源的管理、缓存等。
                initializeResourceManager();

                // 初始化velocity指令配置：org/apache/velocity/runtime/defaults/directive.properties。加载8个预定义指令，比如Foreach，以及userdirective配置的用户指令。
                initializeDirectives();

                // 初始化5种事件处理器，包括空值处理、异常处理等。详见org.apache.velocity.app.event包。
                initializeEventHandlers();

                // 初始化解析器池。
                initializeParserPool();

                // 初始化反射处理类。
                initializeIntrospection();

                // 初始化宏工厂，我们日常使用的macros.vm。
                vmFactory.initVelocimacro();
        ...
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化过程涉及到比较多的点，本文将不展开分析，着重分析其中两个点：解析器和反射，也正是关键的运行步骤中的2、3。&lt;/p&gt;

&lt;h3 id=&quot;4抽象语法树ast&quot;&gt;4.抽象语法树AST&lt;/h3&gt;

&lt;p&gt;Velocity是通过JavaCC和JJTree生成抽象语法树的。说到JavaCC我们先来了解它相关的几个概念。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BNF – 复杂语言的语法通常都是使用 BNF（巴科斯-诺尔范式，Backus-Naur Form）表示法或者其“近亲”― EBNF（扩展的 BNF）描述的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BNF 规定是推导规则(产生式)的集合，写为：
&amp;lt;符号&amp;gt; ::= &amp;lt;使用符号的表达式&amp;gt;

这里的 &amp;lt;符号&amp;gt; 是非终结符，而表达式由一个符号序列，或用指示选择的竖杠 '|' 分隔的多个符号序列构成，每个符号序列整体都是左端的符号的一种可能的替代。从未在左端出现的符号叫做终结符。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaCC 是一个用于生成解析器的工具，它可以将一份语法定义（以.jj为后缀的文件）转化成Java代码用于检查一本文本是否符合这一份语法定义。&lt;/p&gt;

  &lt;p&gt;JJTree 是JavaCC提供的一个工具，JJTree可以将一份语法定义（以.jjt为后缀的文件，语法和.jj文件基本相同）转化成Java 代码，这段代码可以检查一份输入是否符合这一份语法定义。并且最后还会生成一颗抽象语法树提供给使用者来遍历。Velocity就将其模板语法定义成了一个jjt文件，然后根据这一份jjt文件生成了velocity模板的解析器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;41javacc-examples&quot;&gt;4.1.JavaCC Examples&lt;/h4&gt;

&lt;p&gt;简单了解了JavaCC的相关概念之后，我们来看JavaCC自带的例子如何构建一个AST。&lt;/p&gt;

&lt;p&gt;从http://javacc.java.net/下载JavaCC工具(内含JJTree工具)。本文使用5.0版本。&lt;/p&gt;

&lt;p&gt;解压后，进入到javacc-5.0/examples/SimpleExamples目录，先看一个纯JavaCC的简单例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 参数配置段：Simple1中列举了JavaCC配置的默认值。
options {
  ... 
}

// 解析器段：这里可以编写任意Java代码，只要保证PARSER_BEGIN、PARSER_END的参数与Java类名一致。
PARSER_BEGIN(Simple1)

/** Simple brace matcher. */
public class Simple1 {

  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
    Simple1 parser = new Simple1(System.in);
    parser.Input();
  }

}

PARSER_END(Simple1)

// 产生式段
/** Root production. */
void Input() :
{}
{
  MatchedBraces() (&quot;\n&quot;|&quot;\r&quot;)* &amp;lt;EOF&amp;gt;
}

/** Brace matching production. */
void MatchedBraces() :
{}
{
  &quot;{&quot; [ MatchedBraces() ] &quot;}&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上一个jj文件包含几个段落的代码，参数配置、解析器、产生式，常用的还有SKIP(跳词)、TOKEN(关键字)等，更多可参见 https://javacc.java.net/doc/javaccgrm.html。&lt;/p&gt;

&lt;p&gt;正如上面介绍的BNF范式，jj文件中的产生式即是遵循它来实现，只是语法上更贴近Java的方法； 冒号左侧的”符号”即是方法名，冒号右侧的”使用符号的表达式”分为两部分：第一个{}是声明，用于声明变量和一些初始化的动作，如果没有可以忽略，使用方式参见Simple3例子；第二个{}是语法部分和动作部分，语法部分表示左侧可被替换的项，动作部分参见Simple3例子，可以是返回值或者一组动作。&lt;/p&gt;

&lt;p&gt;Simple1的Input方法的语法部分 &lt;code class=&quot;highlighter-rouge&quot;&gt;MatchedBraces() (&quot;\n&quot;|&quot;\r&quot;)*&lt;/code&gt; 的含义是：可被MatchedBraces这个产生式替代，随后可有任意个回车换行符号，最后以文件结束符结尾(是javacc系统定义的TOKEN，表示文件结束符号)。&lt;/p&gt;

&lt;p&gt;MatchedBraces方法的语法部分 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;{&quot; [ MatchedBraces() ] &quot;}&quot;&lt;/code&gt; 的含义是：一个以{开始，并配对的以}结束的串，期间可以有任意个递归的MatchedBraces方法。&lt;/p&gt;

&lt;p&gt;这份解析器可以解析如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;{ }&quot;, &quot;{ { { { { } } } } }&quot;&lt;/code&gt; 这样的串； 不能解析 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;{ { { {&quot;, &quot;{ } { }&quot;, &quot;{ } }&quot;, &quot;{ { } { } }&quot;, &quot;{ }&quot;, &quot;{x}&quot;&lt;/code&gt; 这样的串。&lt;/p&gt;

&lt;h4 id=&quot;42jjtree-examples&quot;&gt;4.2.JJTree Examples&lt;/h4&gt;

&lt;p&gt;接下来，我们通过编译运行的方式看一个结合了JJTree的例子。 进入到javacc-5.0/examples/JJTreeExamples目录，先来手工编译一把eg1.jjt。(本身例子自带ant编译文件，这里了解下编译过程)。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;jjtree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;jjt&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 生成Node文件及jj文件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;javacc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eg1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;jj&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 生成Eg1.java及相关解析文件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;javac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 编译Java源文件&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Eg1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 运行例子，输入待解析的文本&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 回车生成一个AST&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Expression&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;AdditiveExpression&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;MultiplicativeExpression&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UnaryExpression&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;MultiplicativeExpression&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UnaryExpression&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;eg1例子实现了4则运算，先乘除后加减，如果有括号则先解析括号中的。如上如果是一个简单加法运算，它生成的AST将会包含空节点：MultiplicativeExpression(乘除)、UnaryExpression(括号)，除此之外就是一颗树了。大家可以输入更为复杂的4则运算表达式以观察生成的树的构成。&lt;/p&gt;

&lt;p&gt;例子中通过SimpleNode的dump方法输出了Tree。SimpleNode是JJTree中表示一个节点的父类。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SimpleNode n = t.Start();
n.dump(&quot;&quot;);

...

/** Main production. */
SimpleNode Start() : {}
{
  Expression() &quot;;&quot;
  { return jjtThis; }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;42从源码构建velocity的解析器&quot;&gt;4.2.从源码构建Velocity的解析器&lt;/h4&gt;

&lt;p&gt;看完上面的JJTree的简单例子我们就大体上清楚velocity解析器的构建方式。velocity的解析器需要JavaCC 3.2版本以上。&lt;/p&gt;

&lt;p&gt;velocity的jjt文件在src/parser/Parser.jjt，产生的jj文件及其他生成的文件在org.apache.velocity.runtime.parser包下。在其子包node下，有jjt文件生成的一组继承自SimpleNode的节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jjtree Parser.jjt // 生成Parser.jj、一组Node的Java文件骨架(需要自行实现Node的功能性代码)等
javacc Parser.jj // 生成解析器

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终生成的解析器会在Template.process()方法中调用。 要想完整的理解Parser.jjt文件，还需要进一步阅读javacc-5.0/doc/JJTree.html文档，了解jjtree相关的扩展语法。&lt;/p&gt;

&lt;h3 id=&quot;5模板渲染&quot;&gt;5.模板渲染&lt;/h3&gt;

&lt;p&gt;velocity中为了将context中的复杂对象merge到模板中渲染呈现，实现了一套自省机制。可以通过Enterprise Architect来对org.apache.velocity.util.introspection包下的代码做逆向工程，生成UML图以便阅读代码结构。如下图是去除枝节后的类图结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://xiongzheng.me/postimg/velocity1.jpg&quot; alt=&quot;image&quot; /&gt;
​                                         图1 velocity自省类图&lt;/p&gt;

&lt;p&gt;通过类图我们来梳理一下其中的关系。 Uberspect是主要的自省/反射接口，提供方法如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：初始化&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;getIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：支持迭代&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foreach&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：支持方法调用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;$foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;$woogie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;getPropertyGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：支持获取属性值&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;$bar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;woogie&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;getPropertySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：支持设置属性值&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;$foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;geir&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Uberspect的实现UberspectImpl，该实现使用Introspector完成自省功能。Introspector扩展自基类IntrospectorBase，增添日志记录。 IntrospectorBase内部维护了一个IntrospectCache，用于缓存已经完成自省的类和方法信息。 IntrospectorCacheImpl内通过一个HashMap维护一个class与其对应的类型信息，类型信息用一个ClassMap表示。 一个ClassMap内部维护了一个MethodCache，用于缓存该类已经解析出得方法信息。MethodMap表示一个方法信息。&lt;/p&gt;

&lt;p&gt;了解完类图之后，我们来看一个例子，通过这个例子可以更好的理解模板渲染过程。&lt;/p&gt;

&lt;h4 id=&quot;51velocity的ast&quot;&gt;5.1.velocity的AST&lt;/h4&gt;

&lt;p&gt;在org.apache.velocity.runtime.parser包下找到Parser.java(本类即上面通过jjtree&amp;amp;javacc构建的解析器入口文件)。 给Parser.java类加个main方法，以便将解析生成的AST dump输出出来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    String temp = &quot;我是一名来自$company的$person.business('short'),我叫$person.name&quot;;
    CharStream stream = new VelocityCharStream(new ByteArrayInputStream(temp.getBytes()), 0, 0);
    Parser t = new Parser(stream);
    try {
        SimpleNode n = t.process();
        n.dump(&quot;&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出的AST：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*.node.ASTprocess@68a75974[id=0,info=0,invalid=false,children=6,tokens=[我是一名来自],    [$company], [的],  [$person],  [.],    [business], [(],    ['short'],  [)],    [,我叫],  [$person],  [.],    [name], [e]]
    *.node.ASTText@42e20459[id=19,info=0,invalid=false,children=0,tokens=[我是一名来自]]
    *.node.ASTReference@48b915d[id=16,info=0,invalid=false,children=0,tokens=[$company]]
    *.node.ASTText@66f472ff[id=19,info=0,invalid=false,children=0,tokens=[的]]
    *.node.ASTReference@3aa9f827[id=16,info=0,invalid=false,children=1,tokens=[$person],    [.],    [business], [(],    ['short'],  [)]]
        *.node.ASTMethod@6ce2e687[id=15,info=0,invalid=false,children=2,tokens=[business],  [(],    ['short'],  [)]]
            *.node.ASTIdentifier@248ce0ea[id=8,info=0,invalid=false,children=0,tokens=[business]]
            *.node.ASTStringLiteral@1d023565[id=7,info=0,invalid=false,children=0,tokens=['short']]
    *.node.ASTText@7bff88c3[id=19,info=0,invalid=false,children=0,tokens=[,我叫]]
    *.node.ASTReference@456bf9ce[id=16,info=0,invalid=false,children=1,tokens=[$person],    [.],    [name]]
        *.node.ASTIdentifier@33dd66fd[id=8,info=0,invalid=false,children=0,tokens=[name]]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，temp模板中的纯文本被解析为ASTText节点，变量被解析为ASTReference节点，如果是方法则被解析为ASTMethod(方法参数解析为各种类型节点，比如ASTStringLiteral)，如果是属性解析为ASTIdentifier。&lt;/p&gt;

&lt;h4 id=&quot;52merge过程&quot;&gt;5.2.merge过程&lt;/h4&gt;

&lt;p&gt;Template.merge方法中调用了AST的根节点(ASTprocess)的render方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;( (SimpleNode) data ).render( ica, writer);&lt;/code&gt; 。此调用将迭代处理各个子节点render方法。如果是ASTReference类型的节点则在render方法中会调用execute方法执行反射替换相关处理。&lt;/p&gt;

&lt;p&gt;以ASTMethod为例，来看一下execute方法的反射过程。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ASTMethod&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalContextAdapter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodInvocationException&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 获取方法&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;VelMethod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paramCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 获得参数类型&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paramClasses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paramCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paramCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;EMPTY_CLASS_ARRAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paramCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jjtGetChild&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;paramClasses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 尝试从缓存中获取方法&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;MethodCacheKey&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodCacheKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paramClasses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;IntrospectionCacheData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;icacheGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VelMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thingy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 缓存获取不到则使用自省机制获取，并写入缓存&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rsvc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getUberspect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTemplateName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getColumn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntrospectionCacheData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thingy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                    &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;icachePut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;icd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 通过反射调用方法，获得返回值&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getReturnType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ASTMethod的主要执行过程：首先从IntrospectionCache中获取方法，如果没有缓存过，则通过Uberspect反射出方法，并执行方法返回结果。 最终每个节点返回的结果会拼接成文本渲染输出。&lt;/p&gt;

&lt;h3 id=&quot;6小结&quot;&gt;6.小结&lt;/h3&gt;

&lt;p&gt;本文通过源码阅读、样例分析的方式，介绍了velocity如何使用Java提供的JavaCC、JJTree和自省工具达到模板渲染的目的。其中使用的工具和方法希望对读者在其他源码分析过程中有所帮助。&lt;/p&gt;

&lt;p&gt;Java为了能够实现动态语言原生就支持的特性比如：反射、闭包等，需要做很多事情，弄的很复杂的样子；在某些场景下，更适合用动态语言来弥补Java的短板，比如模板、DSL等都可以通过在Java中方便的集成Groovy等脚本语言来支持。&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Nov 2016 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/10/Velocity%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/10/Velocity%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</guid>
        
        
      </item>
    
      <item>
        <title>AWK命令</title>
        <description>&lt;p&gt;简介
awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。&lt;/p&gt;

&lt;!-- more --&gt;
&lt;p&gt;awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。&lt;/p&gt;

&lt;p&gt;awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。&lt;/p&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;p&gt;awk ‘{pattern + action}’ {filenames}
尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。&lt;/p&gt;

&lt;p&gt;awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。&lt;/p&gt;

&lt;p&gt;通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。&lt;/p&gt;

&lt;p&gt;调用awk&lt;/p&gt;

&lt;p&gt;有三种方式调用awk&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;命令行方式&lt;/p&gt;

    &lt;p&gt;awk [-F  field-separator]  ‘commands’  input-file(s)其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;shell脚本方式&lt;/p&gt;

    &lt;p&gt;将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。
相当于shell脚本首行的：#!/bin/sh
可以换成：#!/bin/awk3.将所有的awk命令插入一个单独文件，然后调用：awk -f awk-script-file input-file(s). 其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的awk命令插入一个单独文件，然后调用：
 awk -f awk-script-file input-file(s)
 其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本章重点介绍命令行方式。&lt;/p&gt;

&lt;p&gt;入门实例
假设last -n 5的输出如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@www ~]# last -n 5 &amp;lt;==仅取出前五行
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果只是显示最近登录的5个帐号&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;last -n 5 | awk  '{print $1}'
root
root
root
dmtsai
root
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。&lt;/p&gt;

&lt;p&gt;如果只是显示/etc/passwd的账户&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /etc/passwd |awk  -F ':'  '{print $1}'  
root
daemon
bin
sys
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这种是awk+action的示例，每行都会执行action{print $1}。&lt;/p&gt;

&lt;p&gt;-F指定域分隔符为’:’。&lt;/p&gt;

&lt;p&gt;如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /etc/passwd |awk  -F ':'  '{print $1&quot;\t&quot;$7}'
root    /bin/bash
daemon  /bin/sh
bin     /bin/sh
sys     /bin/sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat /etc/passwd |awk  -F ':'  'BEGIN {print &quot;name,shell&quot;}  {print $1&quot;,&quot;$7} END {print &quot;blue,/bin/nosh&quot;}'
name,shell
root,/bin/bash
daemon,/bin/sh
bin,/bin/sh
sys,/bin/sh
....
blue,/bin/nosh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。&lt;/p&gt;

&lt;p&gt;搜索/etc/passwd有root关键字的所有行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk -F: '/root/' /etc/passwd
root:x:0:0:root:/root:/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。&lt;/p&gt;

&lt;p&gt;搜索支持正则，例如找root开头的: awk -F: ‘/^root/’ /etc/passwd&lt;/p&gt;

&lt;p&gt;搜索/etc/passwd有root关键字的所有行，并显示对应的shell&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; awk -F: '/root/{print $7}' /etc/passwd             
/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里指定了action{print $7}&lt;/p&gt;

&lt;p&gt;awk内置变量
awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。&lt;/p&gt;

&lt;p&gt;复制代码
ARGC               命令行参数个数
ARGV               命令行参数排列
ENVIRON            支持队列中系统环境变量的使用
FILENAME           awk浏览的文件名
FNR                浏览文件的记录数
FS                 设置输入域分隔符，等价于命令行 -F选项
NF                 浏览记录的域的个数
NR                 已读的记录数
OFS                输出域分隔符
ORS                输出记录分隔符
RS                 控制记录分隔符
复制代码
 此外,$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。&lt;/p&gt;

&lt;p&gt;统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk  -F ':'  '{print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0}' /etc/passwd
filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bash
filename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/sh
filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh
filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用printf替代print,可以让代码更加简洁，易读&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; awk  -F ':'  '{printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)}' /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;print和printf
awk中同时提供了print和printf两种打印输出的函数。&lt;/p&gt;

&lt;p&gt;其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。&lt;/p&gt;

&lt;p&gt;printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。&lt;/p&gt;

&lt;p&gt;awk编程
 变量和赋值&lt;/p&gt;

&lt;p&gt;除了awk的内置变量，awk还可以自定义变量。&lt;/p&gt;

&lt;p&gt;下面统计/etc/passwd的账户人数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk '{count++;print $0;} END{print &quot;user count is &quot;, count}' /etc/passwd
root:x:0:0:root:/root:/bin/bash
......
user count is  40
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。&lt;/p&gt;

&lt;p&gt;这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk 'BEGIN {count=0;print &quot;[start]user count is &quot;, count} {count=count+1;print $0;} END{print &quot;[end]user count is &quot;, count}' /etc/passwd
[start]user count is  0
root:x:0:0:root:/root:/bin/bash
...
[end]user count is  40
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;统计某个文件夹下的文件占用的字节数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls -l |awk 'BEGIN {size=0;} {size=size+$5;} END{print &quot;[end]size is &quot;, size}'
[end]size is  8657198
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果以M为单位显示:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls -l |awk 'BEGIN {size=0;} {size=size+$5;} END{print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;}' 
[end]size is  8.25889 M
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意，统计不包括文件夹的子目录。&lt;/p&gt;

&lt;p&gt;条件语句&lt;/p&gt;

&lt;p&gt;awk中的条件语句是从C语言中借鉴来的，见如下声明方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (expression) {
    statement;
    statement;
    ... ...
}

if (expression) {
    statement;
} else {
    statement2;
}

if (expression) {
    statement1;
} else if (expression1) {
    statement2;
} else {
    statement3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls -l |awk 'BEGIN {size=0;print &quot;[start]size is &quot;, size} {if($5!=4096){size=size+$5;}} END{print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;}' 
[end]size is  8.22339 M
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;循环语句&lt;/p&gt;

&lt;p&gt;awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。&lt;/p&gt;

&lt;p&gt;数组&lt;/p&gt;

&lt;p&gt;因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。&lt;/p&gt;

&lt;p&gt;显示/etc/passwd的账户&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk -F ':' 'BEGIN {count=0;} {name[count] = $1;count++;}; END{for (i = 0; i &amp;lt; NR; i++) print i, name[i]}' /etc/passwd0 root
1 daemon
2 bin
3 sys
4 sync5 games
......
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里使用for循环遍历数组&lt;/p&gt;

&lt;p&gt;awk编程的内容极多，这里只罗列简单常用的用法，更多请参考 http://www.gnu.org/software/gawk/manual/gawk.html&lt;/p&gt;

&lt;p&gt;awk统计命令
1、求和
代码示例:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat data|awk '{sum+=$1} END {print &quot;Sum = &quot;, sum}'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2、求平均&lt;/p&gt;

&lt;p&gt;代码示例:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat data|awk '{sum+=$1} END {print &quot;Average = &quot;, sum/NR}'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3、求最大值&lt;/p&gt;

&lt;p&gt;代码示例:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat data|awk 'BEGIN {max = 0} {if ($1&amp;gt;max) max=$1 fi} END {print &quot;Max=&quot;, max}'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;4、求最小值（min的初始值设置一个超大数即可）
代码示例:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk 'BEGIN {min = 1999999} {if ($1&amp;lt;min) min=$1 fi} END {print &quot;Min=&quot;, min}'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 12 Oct 2016 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/10/12/AWK%E5%91%BD%E4%BB%A4.html</link>
        <guid isPermaLink="true">http://localhost:4000/2016/10/12/AWK%E5%91%BD%E4%BB%A4.html</guid>
        
        
      </item>
    
      <item>
        <title>2015-10-18-为什么新生代有两个survivor</title>
        <description>&lt;p&gt;StackOverflow上面给出的解释是：&lt;/p&gt;

&lt;p&gt;The reason for the HotSpot JVM’s two survivor spaces is to reduce the need to deal with fragmentation. New objects are allocated in eden space. All well and good. When that’s full, you need a GC, so kill stale objects and move live ones to a survivor space, where they can mature for a while before being promoted to the old generation. Still good so far. The next time we run out of eden space, though, we have a conundrum. The next GC comes along and clears out some space in both eden and our survivor space, but the spaces aren’t contiguous. So is it better to&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Try to fit the survivors from eden into the holes in the survivor space that were cleared by the GC?&lt;/li&gt;
  &lt;li&gt;Shift all the objects in the survivor space down to eliminate the fragmentation, and then move the survivors into it?&lt;/li&gt;
  &lt;li&gt;Just say “screw it, we’re moving everything around anyway,” and copy all of the survivors from both spaces into a completely separate space–the second survivor space–thus leaving you with a clean eden and survivor space where you can repeat the sequence on the next GC?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sun’s answer to the question is obvious.&lt;/p&gt;

&lt;p&gt;  对于如何达到“无碎片”的目的，理解上可能有些困难，下面我把新生代回收机制详细解释一下：&lt;/p&gt;

&lt;p&gt;  注意，两个survivor是交替使用的，在任意一个时刻，必定有一个survivor为空，一个survivor中存放着对象（连续存放，无碎片）。回收过程如下：&lt;/p&gt;

&lt;p&gt;  S1、GC，将eden中的live对象放入当前不为空的survivor中，将eden中的非live对象回收。如果survivor满了，下次回收执行S2；如果survivor未满，下次回收仍然以S1的方式回收；&lt;/p&gt;

&lt;p&gt;  S2、GC，将eden和存放着对象的survivor中的live对象放入当前为空的survivor中，将非live对象回收。&lt;/p&gt;

&lt;p&gt;  可以看到，上述的新生代回收机制保证了一个survivor为空，另一个非空survivor中无碎片。&lt;/p&gt;

&lt;p&gt;  在执行一定次数的minor GC后，会通过Full GC将新生代的survivor中的对象移入老年代。&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/10/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E6%9C%89%E4%B8%A4%E4%B8%AAsurvivor.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/10/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E6%9C%89%E4%B8%A4%E4%B8%AAsurvivor.html</guid>
        
        
      </item>
    
      <item>
        <title>海量数据相似度计算之simhash和海明距离</title>
        <description>&lt;p&gt;通过 &lt;a href=&quot;http://www.lanceyan.com/tech/arch/tensofmillioncrawler.html&quot;&gt;采集系统&lt;/a&gt; 我们采集了大量文本数据，但是文本中有很多重复数据影响我们对于结果的分析。分析前我们需要对这些数据去除重复，如何选择和设计文本的去重算法？常见的有余弦夹角算法、欧式距离、Jaccard相似度、最长公共子串、编辑距离等。这些算法对于待比较的文本数据不多时还比较好用，如果我们的爬虫每天采集的数据以千万计算，我们如何对于这些海量千万级的数据进行高效的合并去重。最简单的做法是拿着待比较的文本和数据库中所有的文本比较一遍如果是重复的数据就标示为重复。看起来很简单，我们来做个测试，就拿最简单的两个数据使用Apache提供的 Levenshtein for 循环100w次计算这两个数据的相似度。代码结果如下：&lt;/p&gt;

&lt;p&gt;            &lt;a href=&quot;http://www.google.com/search?hl=en&amp;amp;q=allinurl:string+java.sun.com&amp;amp;btnI=I'm%20Feeling%20Lucky&quot;&gt;String&lt;/a&gt; s1 = ”你妈妈喊你回家吃饭哦，回家罗回家罗” ;
            &lt;a href=&quot;http://www.google.com/search?hl=en&amp;amp;q=allinurl:string+java.sun.com&amp;amp;btnI=I'm%20Feeling%20Lucky&quot;&gt;String&lt;/a&gt; s2 = ”你妈妈叫你回家吃饭啦，回家罗回家罗” ;
            long t1 = &lt;a href=&quot;http://www.google.com/search?hl=en&amp;amp;q=allinurl:system+java.sun.com&amp;amp;btnI=I'm%20Feeling%20Lucky&quot;&gt;System&lt;/a&gt;.currentTimeMillis();
            for (int i = 0; i &amp;lt; 1000000; i++) {
                   int dis = StringUtils .getLevenshteinDistance(s1, s2);
            }
            long t2 = &lt;a href=&quot;http://www.google.com/search?hl=en&amp;amp;q=allinurl:system+java.sun.com&amp;amp;btnI=I'm%20Feeling%20Lucky&quot;&gt;System&lt;/a&gt;.currentTimeMillis();
            &lt;a href=&quot;http://www.google.com/search?hl=en&amp;amp;q=allinurl:system+java.sun.com&amp;amp;btnI=I'm%20Feeling%20Lucky&quot;&gt;System&lt;/a&gt;. out .println(“ 耗费时间： “ + (t2 - t1) + ”  ms “);&lt;/p&gt;

&lt;p&gt;耗费时间： 4266 ms&lt;/p&gt;

&lt;p&gt;大跌眼镜，居然计算耗费4秒。假设我们一天需要比较100w次，光是比较100w次的数据是否重复就需要4s，就算4s一个文档，单线程一分钟才处理15个文档，一个小时才900个，一天也才21600个文档，这个数字和一天100w相差甚远，需要多少机器和资源才能解决。&lt;/p&gt;

&lt;p&gt;为此我们需要一种应对于海量数据场景的去重方案，经过研究发现有种叫 local sensitive hash 局部敏感哈希 的东西，据说这玩意可以把文档降维到hash数字，数字两两计算运算量要小很多。查找很多文档后看到google对于网页去重使用的是simhash，他们每天需要处理的文档在亿级别，大大超过了我们现在文档的水平。既然老大哥也有类似的应用，我们也赶紧尝试下。simhash是由 Charikar 在2002年提出来的，参考 &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=509965&quot;&gt;《Similarity estimation techniques from rounding algorithms》&lt;/a&gt; 。 介绍下这个算法主要原理，为了便于理解尽量不使用数学公式，分为这几步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;1、分词&lt;/strong&gt;，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&amp;gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2、hash&lt;/strong&gt;，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3、加权&lt;/strong&gt;，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;4、合并&lt;/strong&gt;，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;5、降维&lt;/strong&gt;，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个过程图为：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lanceyan.com/wp-content/uploads/2013/08/simhash.png&quot;&gt;&lt;img src=&quot;index_files/82f8b2fb-0033-45aa-b015-af89e226601a.png&quot; alt=&quot;simhash计算过程图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;index_files/72a56a17-3fa4-4c84-acf0-780aafe10b1f.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家可能会有疑问，经过这么多步骤搞这么麻烦，不就是为了得到个 0 1 字符串吗？我直接把这个文本作为字符串输入，用hash函数生成 0 1 值更简单。其实不是这样的，传统hash函数解决的是生成唯一值，比如 md5、hashmap等。md5是用于生成唯一签名串，只要稍微多加一个字符md5的两个数字看起来相差甚远；hashmap也是用于键值对查找，便于快速插入和查找的数据结构。不过我们主要解决的是文本相似度计算，要比较的是两个文章是否相识，当然我们降维生成了hashcode也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hashcode却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。&lt;/p&gt;

&lt;p&gt;通过simhash计算结果为：&lt;/p&gt;

&lt;p&gt;1000010010101101&lt;strong&gt;1&lt;/strong&gt;11111100000101011010001001111100001&lt;strong&gt;0&lt;/strong&gt;0101&lt;strong&gt;1&lt;/strong&gt;001011&lt;/p&gt;

&lt;p&gt;1000010010101101&lt;strong&gt;0&lt;/strong&gt;11111100000101011010001001111100001&lt;strong&gt;1&lt;/strong&gt;0101&lt;strong&gt;0&lt;/strong&gt;001011&lt;/p&gt;

&lt;p&gt;通过 hashcode计算为：&lt;/p&gt;

&lt;p&gt;1111111111111111111111111111111110001000001100110100111011011110&lt;/p&gt;

&lt;p&gt;1010010001111111110010110011101&lt;/p&gt;

&lt;p&gt;大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hashcode却不能做到，这个就是局部敏感哈希的魅力。目前Broder提出的shingling算法和Charikar的simhash算法应该算是业界公认比较好的算法。在simhash的发明人Charikar的论文中并没有给出具体的simhash算法和证明，&lt;a href=&quot;http://www.cnblogs.com/linecong/archive/2010/08/28/simhash.html&quot;&gt;“量子图灵”得出的证明simhash是由随机超平面hash算法演变而来的&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;现在通过这样的转换，我们把库里的文本都转换为simhash 代码，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。举例如下： &lt;strong&gt;1&lt;/strong&gt;01&lt;strong&gt;01&lt;/strong&gt; 和 &lt;strong&gt;0&lt;/strong&gt;01&lt;strong&gt;10&lt;/strong&gt; 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。&lt;/p&gt;

&lt;p&gt;为了高效比较，我们预先加载了库里存在文本并转换为simhash code 存储在内存空间。来一条文本先转换为 simhash code，然后和内存里的simhash code 进行比较，测试100w次计算在100ms。速度大大提升。&lt;/p&gt;

&lt;p&gt;未完待续：&lt;/p&gt;

&lt;p&gt;1、目前速度提升了但是数据是不断增量的，如果未来数据发展到一个小时100w，按现在一次100ms，一个线程处理一秒钟 10次，一分钟 60 * 10 次，一个小时 60&lt;em&gt;10 &lt;/em&gt;60 次 = 36000次，一天 60&lt;em&gt;10&lt;/em&gt;60*24 = 864000次。 我们目标是一天100w次，通过增加两个线程就可以完成。但是如果要一个小时100w次呢？则需要增加30个线程和相应的硬件资源保证速度能够达到，这样成本也上去了。能否有更好的办法，提高我们比较的效率？&lt;/p&gt;

&lt;p&gt;2、通过大量测试，simhash用于比较大文本，比如500字以上效果都还蛮好，距离小于3的基本都是相似，误判率也比较低。但是如果我们处理的是微博信息，最多也就140个字，使用simhash的效果并不那么理想。看如下图，在距离为3时是一个比较折中的点，在距离为10时效果已经很差了，不过我们测试短文本很多看起来相似的距离确实为10。如果使用距离为3，短文本大量重复信息不会被过滤，如果使用距离为10，长文本的错误率也非常高，如何解决？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lanceyan.com/wp-content/uploads/2013/08/simhash2.png&quot;&gt;&lt;img src=&quot;index_files/73e2dfd7-7bd8-4154-8c56-630ebcc527ff.png&quot; alt=&quot;simhash_hammingdistance&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考：
&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=1242592&quot;&gt;Detecting near-duplicates for web crawling.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=509965&quot;&gt;Similarity estimation techniques from rounding algorithms.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Locality_sensitive_hashing&quot;&gt;http://en.wikipedia.org/wiki/Locality_sensitive_hashing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Hamming_distance&quot;&gt;http://en.wikipedia.org/wiki/Hamming_distance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1375690611500.html&quot;&gt;simHash 简介以及 java 实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/linecong/archive/2010/08/28/simhash.html&quot;&gt;simhash原理推导&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;来源： &amp;lt;&lt;a href=&quot;http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity.html&quot;&gt;http://www.lanceyan.com/tech/arch/simhash_hamming_distance_similarity.html&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

</description>
        <pubDate>Sat, 15 Aug 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/08/15/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B9%8Bsimhash%E5%92%8C%E6%B5%B7%E6%98%8E%E8%B7%9D%E7%A6%BB.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/08/15/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B9%8Bsimhash%E5%92%8C%E6%B5%B7%E6%98%8E%E8%B7%9D%E7%A6%BB.html</guid>
        
        
      </item>
    
      <item>
        <title>数据库悲观锁乐观锁</title>
        <description>&lt;h2 id=&quot;悲观锁乐观锁&quot;&gt;悲观锁&amp;amp;乐观锁&lt;/h2&gt;

&lt;p&gt;悲观锁与乐观锁是并发访问资源解决冲突不一致的常用的方式，本文将就这两种锁的特点进行讨论。
悲观锁：顾名思义，它对事物持消极态度，它假设他要修改的数据如果不加锁的话会被别人修改，所以它每次操作前先独占锁。悲观者的人生观是一件事情我必须要百分之百完全控制才会去做，否则就认为这件事情一定会出问题；
而乐观者的人生观则相反，凡事不管最终结果如何，他都会先尝试去做，大不了最后不成功。
这就是悲观锁与乐观锁的区别，悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据
&lt;!-- more --&gt;
现在大家很多东西都放在云上面，云上面有一个很不错的功能：云协作。假设有这么一个场景，有一个协作群，群中有两个用户，A&amp;amp;B，其中有一个共享文件F.A看到文件中有一处出错，想去修改它，修改到一半，突然接到一个电话，这时候B也发现F文件中有一个错误，也想去修正，于是也尝试这区修改。A接完电话继续之前的修改。这时，如果没有一个很好地措施，文件最终的结果将很难预料。乐观锁和悲观锁这两个兄弟这时拍拍胸脯说，让我来帮你解决吧。&lt;/p&gt;

&lt;h3 id=&quot;悲观锁&quot;&gt;悲观锁&lt;/h3&gt;

&lt;p&gt;悲观锁说：我有一个防护罩（锁），谁拿到谁就能修改F，于是，A改文件F之前，先问悲观锁要防护罩，如果悲观锁告诉A防护罩已经给别人了，那么A必须等待，反之，如果防护罩空闲，A可以拿到防护罩，拿到之后，罩上文件F（加完锁），A就可以放心大胆的区修改文件F了，因为这时候在防护罩里F被A独享，A可以想什么时候修改完成就什么时候修改完成，随心所欲。但这样问题就产生了，防护罩只有一个，B没有办法及时拿到，没法对F修改，只能等待A修改完成之后，那么显然，并发性将会很差。
想象一下：你已经获得了对象A，但获得对象B之前你不想放弃对象A；但是另一个已经获得了对象B的用户，在获得对象A之前也不想放弃对象B。那么这时候就需要用到超时设置，它可以打破死锁和处理释放锁失败的情况。悲观锁很容易导致死锁的发生。
注：Synchronized互斥锁属于悲观锁。&lt;/p&gt;

&lt;h3 id=&quot;乐观锁&quot;&gt;乐观锁&lt;/h3&gt;
&lt;p&gt;乐观锁说：只有得到我给的口令的人才能对文件F进行修改，于是A，B纷纷想乐观锁要口令，得到口令后，AB都高兴得对文件F修改，由于A中途接电话，修改好的时间比B晚。B提前修改好之后，和乐观锁对对口令，乐观锁发现，哎，口令一致，允许修改。同时乐观锁为了保证一致性，选择保留B的劳动成果，把口令换了，等了一会，A也修改完成了，同样和乐观锁对对口令，发现哎口令不对，修改无效。
但这将会有一个问题，就是如果有很多人同时想对F修改，最终将只有一个人修改成功，其他人还得重试，这时候效率反而会很低。&lt;/p&gt;

&lt;p&gt;可以看一下java中原子增是怎么实现的。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

       &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

       &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getAndIncrement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

               &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

                   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

                   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compareAndSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;

                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

               &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但乐观锁同时也有一些缺点：&lt;/p&gt;

&lt;p&gt;①  观锁只能保证一个共享变量的原子操作。如上例子，自旋过程中只能保证value变量的原子性，这时如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。&lt;/p&gt;

&lt;p&gt;②  长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。&lt;/p&gt;

&lt;p&gt;③  ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://4loc.wordpress.com/2009/04/25/optimistic-vs-pessimistic-locking/&quot;&gt;一个更加有趣的例子&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 10 Jul 2015 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/10/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/10/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81.html</guid>
        
        
      </item>
    
      <item>
        <title>利用sublime快速编写markdown</title>
        <description>&lt;p&gt;插件实现插入带时间功能的说明：&lt;/p&gt;

&lt;h2 id=&quot;创建插件&quot;&gt;创建插件：&lt;/h2&gt;

&lt;p&gt;Tools → New Plugin:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sublime_plugin&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;addInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sublime_plugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;insert_snippet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;contents&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;---&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#you have to start with contents&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; layout:      post&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; title:      &quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; subtitle:      &quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; author:      stillwater&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; dateTime:  &quot;&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strftime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Y-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;m-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;H:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;M:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;S&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; description: Description&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;---&quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;保存为Sublime Text 2\Packages\User\ addInfo.py&lt;/p&gt;

&lt;!-- more --&gt;
&lt;p&gt;####2. 创建快捷键：&lt;/p&gt;

&lt;p&gt;Preference → Key Bindings - User:&lt;/p&gt;
&lt;pre&gt;
[
    {
        &quot;command&quot;: &quot;add_info&quot;,
        &quot;keys&quot;: [
            &quot;ctrl+shift+,&quot;#注意这里我试了一些字母而非标点，貌似没有作用，有可能是因为冲突，没有细究。
        ]
    }
]
&lt;/pre&gt;
</description>
        <pubDate>Mon, 29 Jun 2015 05:08:30 +0800</pubDate>
        <link>http://localhost:4000/2015/06/29/%E5%88%A9%E7%94%A8sublime%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99markdown.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/29/%E5%88%A9%E7%94%A8sublime%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99markdown.html</guid>
        
        
      </item>
    
      <item>
        <title>jekyll read more without plugins</title>
        <description>&lt;h3 id=&quot;adding-support-for--tag-to-jekyll-without-plugins&quot;&gt;Adding support for &lt;!-- more --&gt; tag to Jekyll without plugins&lt;/h3&gt;

&lt;p&gt;Here’s a quick tip for an approach I’ve started using to split post content at a given point for displaying in an archive page, without using a plugin.&lt;/p&gt;

&lt;p&gt;Until recently the approach I took to creating a snippet of a post for my archive page just trimming the post.content to 300 characters in the following way:&lt;/p&gt;

&lt;p&gt;This worked well at first, but when I wrote posts that had very little text before a block of code at the start of the post, the post snippets didn’t look very good:
&lt;img src=&quot;https://blog.omgmog.net/images/by%20default%202013-08-23%20at%2015.33.41.png&quot; /&gt;
There are plugins to allow you to specify where to cut off the content for an excerpt, such as 
&lt;a href=&quot;https://gist.github.com/stympy/986665&quot;&gt;this plugin.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But that won’t work as Jekyll runs with safe: true on GitHub Pages.&lt;/p&gt;

&lt;p&gt;So a solution… Well, Jekyll supports the liquid filters split and first, so we can do the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;post.content&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;strong&amp;gt;Read&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;more&amp;lt;/strong&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then if we include a &lt;!-- more --&gt; in our post at the point that we want to split, we’ll get the post to cut off the content at that point.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.omgmog.net/images/by%20default%202013-08-23%20at%2015.45.23.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So how does it work?&lt;/p&gt;

&lt;p&gt;The split filter&lt;/p&gt;

&lt;p&gt;The first step is to split the content at the &lt;!-- more --&gt; marker using the split filter. When we use split filter, it turns out post.content in to an array with two (or more) parts.
​  &lt;br /&gt;
    {% post.content | split:”&lt;!-- more --&gt;” %}
​&lt;/p&gt;

&lt;p&gt;So we go from:
​  &lt;br /&gt;
    post.content =&amp;gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur libero nibh, semper quis libero sed, molestie molestie nulla.

&amp;lt;!-- more --&amp;gt;

In in augue enim. Aenean fringilla accumsan augue, at convallis quam consequat nec.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then the second step is to use the first filter to just select the part of post.content that came before the &lt;!-- more --&gt; marker:
​  &lt;br /&gt;
    {% post.content | split:”&lt;!-- more --&gt;” | first %}&lt;/p&gt;

&lt;p&gt;Which gives us:
​  &lt;br /&gt;
    post.content =&amp;gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur libero nibh, semper quis libero sed, molestie molestie nulla.&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I also take the steps to strip_html and trim the text to 300 characters.&lt;/p&gt;

&lt;p&gt;Update: You can use Jekyll’s built in “excerpt” feature these days, by doing the following:&lt;/p&gt;

&lt;p&gt;Define your excerpt_separator in your _config.yml: excerpt_separator: “&lt;!-- more --&gt;”
Update the examples I provided before, to use post.excerpt:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;post.excerpt&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 28 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/28/preview-to-Jekyll-without-plugins.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/28/preview-to-Jekyll-without-plugins.html</guid>
        
        
      </item>
    
      <item>
        <title>“(译)bigtable 浅析&quot;</title>
        <description>&lt;h2 id=&quot;bigtable-浅析&quot;&gt;bigtable 浅析&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;    Bigtable 是一个用来管理结构化数据的分布式存储系统，具有很好的伸缩性，能够在几千台应用服务器上处理PB数量级数据。谷歌有许多项目都把数据存储在Bigtable中，包括web indexing,Google Earth, and Google Finance. 这些应用对Bigtable的侧重点不同，但是他们都是海量数据和实时性的应用。尽管需求变化多端，Bigtable很好的提供了一个灵活多变，高性能额解决方案。&lt;/p&gt;
&lt;h3 id=&quot;1introduction&quot;&gt;1.INTRODUCTION&lt;/h3&gt;
&lt;p&gt;    在很多方面Bigtable都与数据库类似：他们有同样的实现策略。并行数据库和主存数据库都具有高伸缩性和高性能的特点。但是Bigtable提供了一种不同的接个口。Bigtable不支持完全的关系数据模型；相反，它给客户端提供了一种简单的数据模型，这种数据模型支持对数据分布和格式的动态控制，并且允许客户端推出底层存储中数据的分布特性。Bigtable的数据可以使用任意字符的行列进行索引，Bigtable也把数据当作不可解释的字符串（uninterpreted strings），尽管客户端常常把不同形式的结构化、半结构化的数据序列化形成这些字符。客户端可以控制通过进行选择模式控制数据的位置。最后一点，调整Bigtable的模式参数能让客户端动态控制是从内存还是硬盘提供数据。
 &lt;!--&lt;!-- more --&gt;–&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;2data-model&quot;&gt;2. DATA MODEL&lt;/h3&gt;
&lt;p&gt;    一个Bigtable 集群是一系列运行Bigtable软件的进程。每一个集群都有一组tables。Bigtable中的表是稀疏的、分布式、持久的多维有序map。其数据有三个维度：行、列、时间戳。
(row:string, column:string, time:int64) → string
    我们称由一个特定行键、列键、时间戳指定的部分为一个单元(cell)。多行组合起来形成负载平衡的基本单元，多列组合起来形成访问控制和资源分配的基本单元。&lt;/p&gt;

&lt;p&gt;  考虑这样一个具体的列子：一个大量网页和相关信息的集合，该集合会被大量不同的应用利用。假设我们称此表为Webtable。在Webtable中，URL为行键，网页的不同方面成为列键，存储网页的内容。时间戳指的是网页被获取的时间。如下图所示
 &lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094651-0e8286ecd46f45f39977ff7045bd5422.jpg&quot; alt=&quot;&quot; /&gt;
    Rows. Bigtable以行键的字典序存储数据，而表中的行键是任意的字符串（目前能达到64KB，尽管对于大部分用户来说10-100字节就够了）。单行数据的读写是串行的（无论该行数据有多少不同的列正被读或者写），这种设计使得客户端能够在对某行数据进行并行更新的时候很容易知道系统的行为。换句话说，行是Bigtable控制事务一致性的基本单元，也就是意味着他不支持跨行事务。
    具有连续键值的行组合成tablets，这是数据分布和负载平衡的基本单元。这样的好处是读取很少的行范围内的数是高效并且一般仅仅需要和少量的机器交互。客户端可以利用这个数据局部性实现高效的数据访问。例如：在Webtable中，相同域名的网页分成一组分布在相邻（contiguous）行，存储的时候把URL的主机部分逆向存储。maps.google.com/index.html会以com.google.maps/index.html作为键存储。把相同域名的网页临近存放使得某些域名和主机分析更加高效。
    Columns. 列键放在一起称为列家族，它是访问控制的基本单元。在一个列族中存放的数据通常是相同类型的。在数据用key存储之前必须显式创建列族。在列族创建完成之后，该族任意的列键都可以使用：数据可以在不影响表模式的前提下存储在这样的列键中。我们的想法是让不同列族数比较少（最多上百），并且这样的列族在操作过程中几本不会改变；这种限制控制了共享元数据的大小。但是其对列数是没有任何限制的。
    改变一个表模式可能会删掉所有的列族，在这种情况下，该族任意列键存储的数据都将被删掉。由于Bigtable并不支持跨行事务，如果数据被存储在多行，特定的列键被删除，其对应的数据可能不会被删掉。
    列键是用如下的语法命名的：族：标识符。列族的名字必须是可打印的，但是标识符没有限制。关于Webtable的一个列族例子是网页编写的语言。在语言族中我们仅使用一个列键和一个空的标识符来存储每个网页的语言ID。该表另一个有用的列族是anchor；该族中的每一个列键都代表一个anchor。标识符就是所指向网址的名字。单元（cell）则包含与链接相关的文本。
    访问控制以及磁盘内存分配调度都使在列族层次上的。在Webtable例子中，这些控制允许我们控制几种不同类型的应用：有些应用新增底层数据，有些则读取底层数据和创建新建的列族，有些仅仅允许访问已存在的数据（甚至由于隐私的原因，不允许访问所有存在的族的数据）&lt;/p&gt;

&lt;p&gt;    TimeStamps. 表中不同单元格可以包含同样数据的不同版本，版本是通过timestamp索引的。Bigtable的时间戳是64位整数。他们可以被Bigtable隐式赋值，这种情况是“实时的”，精确到毫秒级，或者可以被客户端显式赋值。应用程序必须产生唯一的时间戳来避免冲突。不同版本的单元格以降序存储，这样最新版本会被最先读取。
    为了简化版本管理，我们支持两个per-column-family 告诉Bigtable自动进行垃圾版本回收。客户端既可以选择保存最近的几个版本，也可以选择保存足够新的版本（例如，仅保存最近七天写入的）
    在Webtable例子中，我们可以把时间戳存储在扒取网页的内容中：这列意味着这些网页版本实际扒取的时间。上面描述的垃圾回收机制使得Bigtable仅保存每个网页的最近三个版本。&lt;/p&gt;

&lt;h3 id=&quot;3-api&quot;&gt;3. API&lt;/h3&gt;

&lt;p&gt;    Bigtable的API提供了创建和删除表和列族的函数。同样也提供了改变集群、表和列族元数据的函数，例如访问控制权限。
    客户端程序可以删除Bigtable中的值或者向Bigtable中写入数据，从单行中检索数据，或者对表中数据子集进行迭代。&lt;/p&gt;

&lt;p&gt;图2描述了C++代码使用RowMutation抽象进行一系列更新操作。（无关细节略去了）调用Apply执行对Webtable的原子操作：向www.cnn.com增加了一个anchor，同时删除了一个不同的anchor。&lt;/p&gt;

&lt;p&gt;    图3 描述了C++使用一个Scanner抽象对某一个特定row的所有anchor进行迭代。客户机可以在不同的列族进行迭代，不过也有一些机制来限制scan可以遍历的行、列、时间戳。例如：我们可以限制让scan仅仅扫描那些匹配正则表达式的列，或者对时间戳进行限制来选择。
    Bigtable支持不同的特性让用户能够以复杂多变的方式操作数据。首先，Bigtable支持单行事务，这个特性使得对单行数据可以执行原子的读写序列。Bigtable目前还不迟滞跨行事务，尽管其给客户机提供了一个接口可以跨行批量写入。第二，Bigtable允许单元格充当整数计数器。第三，Bigtable支持客户端提供的脚本在服务器地址空间中执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094749-fbb3aadf1bdb4cd494db36491d939e13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4building-blocks&quot;&gt;4. BUILDING BLOCKS&lt;/h3&gt;
&lt;p&gt;    Bigtable 是基于其他几个Google基本结构的。一个Bigtable集群通常在运行各种各样分布式应用程序的共享机器上运行。Bigtable依赖于谷歌的集群管理系统来调度任务，管理资源，监控机器状态，处理异常机器。Bigtable进程与其他应用程序进程共享机器。如图4所示，一个Bigtable服务器可能与MapReduce、应用服务器、GFS服务器等运行在同一个机器上。
&lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094819-4e0e8bbefbf44428bf8b08c2adbc8db6.jpg&quot; alt=&quot;&quot; /&gt;
    Bigtable 使用GFS来存储日志和数据文件。GFS是一个分布式文件系统，可以保存每个文件的多个备份以提高可靠性和易用性。
    Bigtable使用Google SSTable不变文件格式存储Bigtable数据文件。一个SSTable提供了一个持久的有序不变的从key到values的map。用户可以通过指定的key查找关联的value，也可以对指定的key范围内数据迭代。每一个SSTable都包含了连续的几个块（默认情况下，每个块64KB，但是大小是可以配置的）块索引（存放在SSTable的最后）是用来定位块的；当SStable打开时索引就被加载进内存。这样查询只需要一次磁盘寻道:首先通过对内存索引进行二分查找找到对应的块。根据实际情况，一个SSTable可以完全被映射到内存，从而在执行查找和扫描是无需访问硬盘。
    Bigtable依赖一个高易用性、持久化的分布式锁机制——Chubby。一个Chubby服务由五个活动的副本组成，其中一个被选为主要的用来处理请求。当大部分副本都处于运行状态并且相通信时Chubby处于活动状态，Chubby使用Paxos算法来保证在遇到问题时副本之间的一致性。Chubby还提供了一个由目录和小文件组成的名字空间。每一个目录或文件都可以当作锁，读写文件都是原子操作。Chubby客户端库都提供了对Chubby文件的一致映射。每一个Chubby客户端都和Chubby服务维持一个会话（session）.当客户端session不能够在到期之前续期就会失效，当session失效后，它将失去所有的锁。Chubby客户端可以对文件或目录注册一个回调函数以便在session超期或发生改变时接受通知。
    Bigtable的Chubby可以处理不同的任务：保证任何时候之多只有一个master；存储Bigtable数据的启动位置（见5.1）；寻找tablet服务器以及确定tablet服务器的死亡（见5.2）；存储Bigtable模式（见5.5）。如果Chubby服务在一段时间内不可用，Bigtable就会不可用&lt;/p&gt;
&lt;h3 id=&quot;5implementation&quot;&gt;5.IMPLEMENTATION&lt;/h3&gt;
&lt;p&gt;    Bigtable的实现主要包括三哥主要部分：一个链接到每个客户端的库，一个master服务器，许多tablet服务器。Tablet 服务器可动态添加到集群（或删除）以适应不同的负载。
    master服务器负责把tablets分配到tablet服务器上，检测tablet服务器的增加和超期，平衡tablet服务器负载，对GFS进行垃圾收集。此外，还能处理模式改变，例如列族的创建和删除。
    每一个tablet服务器都管理一组tablets(一般每个tablet服务器上有10-1000个tablets)。tablet服务器处理对该服务器上tablets的读写请求，也能够将特别大的tablets分成几个。
    像许多单master的分布式存储系统一样，客户端的数据不会移动到master上：客户端直接与tablet服务器进行读写交互。因为Bigtable客户端无需通过master知道tablet的位置信息，大部分client从来都不喝master交互。这样，在实际中，master的负载就会特别小。
    一个Bigtable集群存储了大量的tables。每一个表都由一组tablets构成，每一个tablet包含一个行范围内的数据。初始情况下，每个表仅包含一个tablet。随着表大小的增长，它会自动分裂成多个tablets，默认每个表可以达到1GB。
    尽管，我们的模型支持任意大小的数据，但是目前的Bigtable的实现还不能非常大的数据。下面的部分江介绍Bigtable实现的细节情况。&lt;/p&gt;
&lt;h4 id=&quot;51tablet-location&quot;&gt;5.1 Tablet Location&lt;/h4&gt;
&lt;p&gt;    我们使用一个类似于B+树的三层结构存储位置信息。第一层是存储在Chubby中的文件，该文件包含root tablet的位置信息。root tablet包含一个特殊METADATA table所有teblets的位置信息.每一个tablet包含许多用户tablets的位置信息。root tablet和其他tablet有所不同——从来不会分裂——这种特性使得tablet位置层次结构不会超过三层。
    METADATA表用一行存储一个tablet的位置信息，位置信息包括tablet表标识符的编码和末行号。每一个METADATA行大约占用1KB的内存。而每个METADATA表的上限是128MB，这样我们三层结构能够处理2^34的tablets。
    客户端库遍历位置层次结构定位tablets，并且缓存寻找到的tablet的位置。如果client不知道一个tablet的位置，或者它发现它缓存的信息是错误的，那么它将第贵的在位置层次结构中移动。如果客户端缓存是空的，这种寻找算法需要三次来回传递消息，包括一次从Chubby中读取。如果客户端缓存中的信息过时了，这中算法需要6次来回消息传递才能找到某一个tablet，由于过时的缓存项只有在miss的情况下才会发现。尽管tablet位置信息存储在内存中，无需GFS访问，我们通过客户端库预取tablet位置信息进一步减少这种通常情况下的开销：不管什么时候客户端读取METADATA表时多读取几个tablet的metadata。
    我们同样在METADATA表中存储了耳机信息，包括与每一个tablet相关的所有事件的日志（如服务器向其提供服务的时间）这种信息对调试和性能分析的作用是很大的。&lt;/p&gt;

&lt;h4 id=&quot;52tablet-assignment&quot;&gt;5.2 Tablet Assignment&lt;/h4&gt;
&lt;p&gt;        每一个tablet一次至多只能分配给一个tablet服务器。master服务器跟踪这些活动的tablet 服务器以及当前正被分配给tablet 服务器的tablet，包括违背分配的tablets.当一个tablet是未分配的，tablet server 有足够的空间容纳一个tablet，master就会通过向tablet server发送一个tablet装载请求给tablet分配服务器。分配只有在一个master的失效备援工作之前tablet装载请求还没有收到：因为tablet server 仅接受当前master的装载请求。因此当一个master服务器发送了一个装载请求，它可以假设这个tablet被赋给了某个tablet服务器知道该服务器死亡，或者该tablet服务器通知master它已经卸载了该tablet.
        Bigtable使用Chubby跟踪这些tablet服务器，当一个tablet服务器启动时，在一个特定的Chubby目录下，对一个唯一名字的文件创建一个排它锁。master监测此目录来发现tablet服务器。当tablet失去排它锁时，就会停止对其上的tablets提供服务。例如：网络中断可能导致服务器失去和Chubby的会话。tablet服务尝试重新获取一文件的排它锁只要它的文件依旧存在。如果它的文件不存在了，服务器将不能提供任何服务，它就会终结它自己。不论什么时候tablet服务器终止，它将尝试释放自己的锁，以便master可以更快的给它的tablets分配新的服务器。
        master负责检测tablet服务器不再向tablets提供服务的情形，尽可能快的重新分配这些tablets。为了检测一个tablet 服务器不再向tablet提供服务，master周期性询问每一个tablet服务器的锁的状态。如果某个tablet服务器告诉master它丢失了它的锁，或者master几经尝试都不能够到达一个tablet服务器.master就会尝试获取服务器文件排它锁。如果master能够获取该锁，这说明chubby正常并且tablet服务器要么终结了要么不能够到达Chubby.master将会通过删除它的服务器文件保证该tablet服务器永远都不能够再提供服务。一旦一个服务器文件被删除，master就会将之前分配给他的tablets重新变成未分配的。为了确保master和Chubby之间不易受到网络问题的影响，master终结自己当它与Chubby之间的会话插旗。master失败并不会影响tablets分配。
    当一个master被集群管理系统启动时，在改变tablet分配之前，它需要知道当前的tablet分配情况。在启动时，master会执行以下的步骤：
    （1）首先master会在Chubby中获取一个为一个master lock,此锁可以避免并行的master实例
    （2）master扫描Chubby的servers目录发现活动的tablet 服务器
    （3）master与每一个活动的tablet server交互发现那些tablets已经分配到每一个服务器，更新当前master所了解到的信息（任何之前masters发送的tablet装载请求都会被拒绝)
    （4）master扫描METADATA表知道有哪些tablets.不论什么时候扫描到一个没有被分配的tablet,master把这个tablet放到未分配tablet集合中，这样可以是得tablet分配更加方便。
        
        一个比较复杂的事情是只有当METADATA tablets已经被分配之后才能够扫描METADATA表。因此，在开始扫描之前（第四步），master把root tablet加到未分配tablet集合中如果在第三步中没有对root tablet进行分配。这会保证root tablet会被分配。因为root tablet包含所有的METADATA表的名字，master在扫描完root tablet之后就会知道所有的METADATA表的名字。
        这些tablets集合只有在表创建或删除的时候、俩个tablets合并成一个更大的tablet,或者一个tablet分裂成俩个更小的tablets时才会改变。master能够跟踪这些改变因为除了最后一个操作，其他操作都是由master初始化的。对于tablets分裂需要特殊对待，因为这个操作是由tablet servers启动的。tablet server 分裂过程是这样的，在METADATA表中记录新的tablet server的信息。在执行分裂之后，tablet server通知master.如果分裂通知丢失（由于tablet server或者master死亡）。master会发现该新的tablet当其要求tablet server加载已经分裂的tablet的时候。tablet server会告知master关于该分裂，因为master发现在METADATA表中的tablet项仅能描述它要求加载tablet的一部分信息。&lt;/p&gt;

&lt;h4 id=&quot;53tablet-serving&quot;&gt;5.3 Tablet Serving&lt;/h4&gt;
&lt;p&gt;        tablet的持久化信息被存储在GFS中，如图6所示&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094848-56256e5d4b4b4f8aa5088e027c5edd80.jpg&quot; alt=&quot;&quot; /&gt;
        更新信息都被提交到一个存储恢复记录的commit log中。最近提交的信息都被存储在内存中的一个叫做memtable的有序缓冲中。一个memtable保存了row-by-row basis的更新，每一行都通过写时复制来保证行层次的一致性。更早的更新存储在一系列的SSTables中（不可改变）
        为了恢复一个tablet，tablet server从METADATA表中读取元数据。这些元素据包括组成tablet和一系列的还原点的SSTables，这些元数据可能包含tablet数据的提交日志的指针。server把SSTables的索引读进内存，通过还原点中更新记录重构memetable。
        当tablet server接受到一个写操作请求，server检查该请求是否是良定义的，发送者是否有权限执行该操作。检查权限是通过Chubby文件中一个允许写的列表（该文件在CHubby客户端缓存中，几乎每次都能命中）。合法的改变都会写入到提交日志中。批量提交小的改变可以提高系统吞吐量。当写操作提交之后，内容就被插入到memtable总。
        当tablet server接收到一个读操作时，同样先检查其形式和权限。
        当tablets正在分裂或者合并的时候读写操作仍然可以继续。当tablets在被压缩时，读写操作仍然可以进行。&lt;/p&gt;
&lt;h4 id=&quot;54compactions&quot;&gt;5.4 Compactions&lt;/h4&gt;
&lt;p&gt;        当执行写操作时，memtable大小增加。当memtable大小达到阈值时memtable就会被冻结，一个新的memtable会被创建，冻结的memtable会被转换成SSTable并被写入到GFS中。这种小型压缩过程有两个目的：减少tablet server的内存消耗，减少在server死亡情况下恢复过程中需要从commit log中读取的数据量
        每一次微小压缩（minor compaction）都会创建一个新的SSTable。如果这种行为不受约束，读操作可能需要合并任意数量的SSTable中的更新记录。相反，如果我们限制了这些文件的数目通过在后台周期性执行一个合并压缩。合并压缩读取几个SSTable和memtable的内容，写入到一个新的SStable中。当压缩完成后，输入SSTables和memtable可以被丢弃掉。
        把所有SSTables中的内容写入到一个SSTable的合并操作称之为大的合并。由小型压缩产生的SSTables可以包含特殊的删除项，该删除项可以限制在比较老的SStable中仍然存活着的数据。另一方面，大的压缩产生的SSTable不包含任何删除信息或数据。Bigtable周期性的检测所有的tablets并且周期性应用大的压缩。这些大的压缩让Bigtable回首被删除数据使用的水资源，同时也能保证让需删除的数据机试从系统中小时，这一点对于存储敏感数据的服务很重要。
        Bigtable读性能得以与GFS的局部性优化。当文件被写入时，GFS尝试把数据的副本放在写者的机器上。当读取GFS文件时，读取的数据来源于最近可用的副本中。因此，在tablet servers与GFS servers共享机器时，tablet servers会压缩到在硬盘上有副本的SStables中，这样可以在处理连续的读请求时快速访问这些SSTables&lt;/p&gt;

&lt;h4 id=&quot;55模式管理&quot;&gt;5.5模式管理&lt;/h4&gt;
&lt;p&gt;        BigTable的模式存储在Chubby中。Chubby给Bigtable模式提供了一个搞笑的交流基质，它提供了对整个文件原子写操作和小文件的一致性缓存。列入，假设一个客户端程序想要删除表中的某些列族。master执行访问控制检查，验证结果模式是梁定义的，然后向Chubby中重写相应的模式来安装新的模式。不论什么时候tablet servers需要决定那些列族存在，仅需要读取Chubby中相应的模式，这在Chubby的客户端缓存中常常是存在的。因为Chubby缓存是一致的，tablet servers 一定能够看到对那个文件的所有改变。&lt;/p&gt;

&lt;p&gt;        参考资料：
　　　　Bigtable: A Distributed Storage System for Structured Data&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/28/(%E8%AF%91)bigtable%E6%B5%85%E6%9E%90.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/28/(%E8%AF%91)bigtable%E6%B5%85%E6%9E%90.html</guid>
        
        
      </item>
    
      <item>
        <title>github搭建个人博客</title>
        <description>&lt;h3 id=&quot;githubmarkdownjekyll-搭建个人博客&quot;&gt;GitHub+Markdown+Jekyll 搭建个人博客&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;首先以下所有内容都是针对mac的，不同系统装的软件差不多，但过程千差万别，如果是其他系统凉快去。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;&lt;em&gt;准备工作&lt;/em&gt;：&lt;/h3&gt;
&lt;p&gt;mac中自带git和gem.这两者就不用安装了，gem是一种文件组织的包，一般的ruby的很多插件都有由这种各种的包提供。安装Jekyll需要它的支持。&lt;/p&gt;
&lt;h4 id=&quot;安装jekyll&quot;&gt;&lt;em&gt;安装jekyll&lt;/em&gt;&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gem update —system
$ sudo gem install jekyll 注意需要sudo，否则 no permission.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接运行以上命令会出现一些错误。运行以下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem sources -l 可以看到终端显示 \*\*\* CURRENT SOURCES \*\*\*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;https://rubygems.org
可见gem的源默认是https://rubygems.org/，
所以首先更换gem源，换源之前首先删除旧源
	$ gem sources –remove https://rubygems.org
注意不要多字符或少字符，不然会出现
source https://rubygems.org not present in cache 
remove前是—，否则会
source emove not present in cache&lt;/p&gt;

&lt;h4 id=&quot;添加新源&quot;&gt;&lt;em&gt;添加新源&lt;/em&gt;&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem sources -a https://ruby.taobao.org/ 这是一个完整 rubygems.org 镜像，你可以用此代替官方版本，同步频率目前为15分钟一次以保证尽量与官方服务同步。 添加完成之后查看一下是否更换成功

$ gem sources -l &amp;lt;!-- more --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在最新版本的macos系统中可能出现无法安装的情况，按照以下步骤处理&lt;/p&gt;

&lt;p&gt;1.http://stackoverflow.com/questions/31972968/cant-install-gems-on-os-x-el-capitan&lt;/p&gt;

&lt;p&gt;2.更新xcode&lt;/p&gt;

&lt;p&gt;3.https://jekyllrb.com/docs/troubleshooting/#jekyll-amp-mac-os-x-1011&lt;/p&gt;

&lt;p&gt;更换markdown模板解释器
安装模板,默认的模板是Maruku,我们替 换为RDiscount。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gem install rdiscount Maruku是纯ruby写的Markdown模板解释 器。 RDiscount是C写的模板解释器。速度快上很多。 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完jekyll之后，我们需要创建网站的各种目录结构和源文件。由于这些文件最终在github中管理，如何利用github创建网站可以看github pages.这里直接直接将整个过程融入一个完整blog的构建过程。
让github管理本地文件有两种方式：
由于github托管的网站必须是username.github.io,对应的仓库也是username.github.io
1.首先git clone username.github.io到本地，会在本地创建一个 username.github.io文件夹，cd进去一看是空的，输入命令ls -a可以发现有一个.git文件，这个文件联系起了本地和远程git服务器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone git@username.github.io.git
$ cd username.github.io
$ jekyll new blog
$ cd blog
$ jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.可以事先在本地创建完blog之后，在创建git文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll new blog
$ cd blog
$ git init git init会在本地创建一个.git文件,Initialized empty Git repository in yourPath/.git/

$ git add */git add —all
$ git commit -m “commit”
$ git remote add origin 
git@git@username.github.io.git (若是第一次提交该项目的文件或是修改项目文件名后则需要这行这个命令，以后就可不用执行该命令)

git push -u origin master 如果之前已经 add origin，则会报出如下错误： fatal: remote origin already exists. 解决方法：

git remote set-url origin git@git@username.github.io.git 这将替换之前添加的orgin。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时访问username.github.io，将会看到你刚刚创建的网站。
可以看到Jekyll目录结构&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–_config.yml&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_drafts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–articles1.textile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–articles2.md&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_includes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–footer.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–header.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_layouts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–default.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–post.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_posts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–2014-06-17-articles1.textile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–2014-06-17-articles1.md&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_site&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–index.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–other files&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;_config.yml :保存配置数据。 
_drafts :存放未发布的文章。&lt;br /&gt;
_includes :存放页面片段,即页头 ( head.html )、页脚&lt;br /&gt;
( footer.html )、导航&lt;br /&gt;
( navigation.html )、评论 
( disqus_comments.html )等,这些 资源通过标签添加到index.html中,从而形 成一个完整的页面。 
_layouts :存放模板文件。文章模板、 关于页面模板、首页模板等。 
_posts :存放文章的文件。并且文章文 件名称要符合 YEAR-MONTH-DAY- title.MARKUP 格式。 
_site :经过jekyll转换的页面。 
index.html :网站首页。 
other files :其他文件,存放css、 js、image等。&lt;/p&gt;

&lt;p&gt;更多配置：http://jekyllrb.com/docs/configuration/&lt;/p&gt;

&lt;p&gt;Jekyll解析流程 
首先会加载_posts及文件夹下的所有文章, 将其参数和文章内容组织保存在内存中,所 有的文章的内容、参数都在site.posts对象 (其他文件夹下的文章不会放入site.posts 中)。 
其次加载_layouts文件夹下的所有模板。 再次加载_includes文件夹下的所有需要被引入的内容。 
最后根据每一篇需要编译的文章选择的其参 数定义的模板来创建一个模板,并将当前文 章的内容、参数等进行扩展后放在page对 象、content对象中,然后进行模板的编 译,生成html文件,并按照一定规则放在 _site文件夹下。也就是说在创建一篇文章 时,其实所有文章的内容都已经被读取出来 了,这也为文章相互之间的关联提供了可 能。&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/27/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/27/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</guid>
        
        
      </item>
    
      <item>
        <title>jar包冲突好玩的排查方式</title>
        <description>&lt;p&gt; 在测试脚本编写和应用部署时，经常遇到的一个问题是：java.lang.NoSuchMethodError。这个问题产生的根本原因是运行时应用加载的jar包版本不是应用代码真正需要的版本。要解决这个问题，就要让应用加载真正“HasSuchMethod”的类所在的jar包。解决这个问题，我把它归纳为以下几步：验证加载内容、查找包含该类的jar包、查找应用适用的jar版本、查看出错应用加载的jar包位置、替换错误jar包版本到需要的版本。&lt;/p&gt;

&lt;p&gt;   &lt;strong&gt; 验证加载内容&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    通常，发生了NoSuchMethodError，在报错中我们可以查看到应用真实需要的方法和方法签名，例如如下的报错：&lt;/p&gt;

&lt;p&gt;java.lang.NoSuchMethodError: com.taobao.eagleeye.EagleEye.rpcClientRecv(Ljava/lang/String;I)V&lt;/p&gt;

&lt;p&gt;    表明应用需要的是EagleEye类中的包含方法签名如：void rpcClientRecv(String str,int i)的方法。知道了这一点，我就自然需要去看一下应用中实际加载的EagleEye是什么样的情况，rpcClientRecv方法的签名是什么样子的。&lt;/p&gt;

&lt;p&gt;    要得到这些内容，可以用两个工具来获取，1是classdump工具，它通过Serviceability Agent技术在运行时dump指定的类的字节码文件。2是jdgui，这是使用得最多的反编译工具，它可以把classdump工具dump出来的字节码文件反编译成java代码，可以更直观得查看应用中加载的类是什么样子。&lt;/p&gt;

&lt;p&gt;    classdump工具的使用：&lt;/p&gt;

&lt;p&gt;    命令：java -classpath ”.:/opt/taobao/java/lib/sa-jdi.jar” sun.jvm.hotspot.tools.jcore.ClassDump 16528&lt;/p&gt;

&lt;p&gt;    其中-classpath把sa-jdi的jar包加入到classpath中，ClassDump 是执行字节码文件dump的main方法入口类，16528是目标进程的pid，可以用jps命令得到。&lt;/p&gt;

&lt;p&gt;    这样，ClassDump会把当前加载的所有Java类都dump到当前目录下，如果有全限定名相同但内容不同的类同时存在于一个Java进程中，那么dump的时候会有覆盖现象，实际dump出来的是同名的类的最后一个。&lt;/p&gt;

&lt;p&gt;    如果需要指定被dump的类的范围，可以自己写一个过滤器，在启动ClassDump工具时指定-Dsun.jvm.hotspot.tools.jcore.filter=filterClassName，如果需要指定dump出来的Class文件的存放路径，可以用-Dsun.jvm.hotspot.tools.jcore.outputDir=path来指定，path替换为实际路径。&lt;/p&gt;

&lt;p&gt;    对于上面讲的例子，我们只需要EagleEye类的内容，那么，就可以写一个FilterClass类来进行dump的过滤，写这个过滤类，需要实现sun.jvm.hotspot.tools.jcore.ClassFilter，具体实现如下图所示，InstanceKlass对应于HotSpot中表示Java类的内部对象，我们只要过滤类名以com/taobao/eagleeye的类就好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006tNc79gy1fco765hjv3j30dt05lq3o.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;写好了这个类之后，编译，把这个类的class文件放到要执行ClassDump命令的目录下，执行时增加如下参数：-Dsun.jvm.hotspot.tools.jcore.filter=MyFilter，ClassDump就会在当前目录dump出com.taobao.eagleeye.EagleEye类的字节码。&lt;/p&gt;

&lt;p&gt;    然后使用jd-gui，jd-gui是一个绿色工具，直接打开字节码文件，可以看到rpcClientRecv方法，这里就可以看到，实际上当前jvm加载的是一个没有参数的rpcClientRecv方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tNc79gy1fco7724l7ej30sg0eo76g.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    查找包含该类的jar包、查找应用适用的jar版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    确认了当前出现错误的应用中确实加载了不符合要求的类之后，就需要去看一下，这个类是从哪里来的，在哪个jar包中。做这件事情比较简单，只需要去eclipse中执行ctrl+shift+t，输入类名，就可以看到当前eclipse的工程中依赖的各个版本的包含这个类的jar包。接下来你可以把各个版本的类都打开，检查这些版本的jar包中是否有符合要求的方法，即方法签名符合rpcClientRecv(Ljava/lang/String;I)V的方法。方法签名识别：其中L开头，；结尾的字符串标识了一个对象类型，这里的第一个参数是java.lang.String类型，第二个参数是int类型，V表示void类型返回。详细的jvm中字段类型和方法签名表示见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tNc79gy1fco77x349gj30j60gaac6.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    通过这个步骤，我们知道了实际上我们的应用需要什么版本的jar包，那么，接下来自然就会想要知道应用当前加载的是什么版本的jar包，又是在哪里加载进来的。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;查看出错应用加载的jar包和jar包位置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;在这个步骤，要想知道应用加载的是jar包的什么版本，需要使用jvm类加载跟踪器这个工具，这是一个基于java agent、instrument的，用于排查jar包冲突、类冲突、类版本冲突、NoClassDefFoundError、ClassNotFoundException、NoSuchMethodError 等类加载相关问题的辅助工具。这个工具的能够定时得把新加载入虚拟机类个jar包等数据输出到指定的html文件中。&lt;/p&gt;

&lt;p&gt;    工具的使用方式是：首先，下载得到jvminspect.jar；其次，修改目标应用的jvm配置，在jvm参数上增加如下的配置：JAVA_OPTIONS=$JAVA_OPTIONS -javaagent:jvminspect.jar=outputfile=jvm.inspect.output,flushIntervalSecond=300 -DHtmlFlusher.enableHyperlink=false；其中jvminspect.jar是下载得到的工具jar包，jvm.inspect.output是输出的文件地址，flushIntervalSecond参数指定的是定时刷新的时间间隔。增加了这个参数之后重启，就可以在jvm.inspect.output文件中查看这个jvm进程加载类的情况了。&lt;/p&gt;

&lt;p&gt;    我们关心的是出现NoSuchMethodError 所在的类，在这个例子中，这是com.taobao.eagleeye.EagleEye类，在输出的文件中我们可以看到这个类被jvm从jar包的哪个版本中加载，jar包的物理位置等信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tNc79gy1fco781c45bj30sg030ac0.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    知道了这些信息，我们就很清楚得能够确定问题的原因。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;替换错误jar包版本到需要的版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;知道应用在那里加载了不期望被加载的jar包，我们就可以着手让应用把需要加载的正确版本包加载进来。不同的场景可以做不一样的操作，比如应用的war包中本身加载了错误版本的jar包，那你需要做的是修改应用的pom文件进行重新打包，把正确的jar包依赖到war包中；如果是由于某些环境的原因，classpath中存在了两个不同版本的jar包，那你就可以根据前面几步得到的信息，把错误版本（导致应用报NoClassDefFoundError、ClassNotFoundException、NoSuchMethodError等错）的版本删除，留下应用代码实际上依赖的jar包。&lt;/p&gt;

</description>
        <pubDate>Tue, 09 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/09/jar%E5%8C%85%E5%86%B2%E7%AA%81.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/09/jar%E5%8C%85%E5%86%B2%E7%AA%81.html</guid>
        
        
      </item>
    
  </channel>
</rss>
