<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>stillwater</title>
    <description>Hello, My Name is stillwater, I'm a software Engineer and Web Developer from China. </description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 12 Feb 2017 23:21:18 +0800</pubDate>
    <lastBuildDate>Sun, 12 Feb 2017 23:21:18 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>数据库悲观锁乐观锁</title>
        <description>&lt;h2 id=&quot;悲观锁乐观锁&quot;&gt;悲观锁&amp;amp;乐观锁&lt;/h2&gt;

&lt;p&gt;悲观锁与乐观锁是并发访问资源解决冲突不一致的常用的方式，本文将就这两种锁的特点进行讨论。
悲观锁：顾名思义，它对事物持消极态度，它假设他要修改的数据如果不加锁的话会被别人修改，所以它每次操作前先独占锁。悲观者的人生观是一件事情我必须要百分之百完全控制才会去做，否则就认为这件事情一定会出问题；
而乐观者的人生观则相反，凡事不管最终结果如何，他都会先尝试去做，大不了最后不成功。
这就是悲观锁与乐观锁的区别，悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据
&lt;!-- more --&gt;
现在大家很多东西都放在云上面，云上面有一个很不错的功能：云协作。假设有这么一个场景，有一个协作群，群中有两个用户，A&amp;amp;B，其中有一个共享文件F.A看到文件中有一处出错，想去修改它，修改到一半，突然接到一个电话，这时候B也发现F文件中有一个错误，也想去修正，于是也尝试这区修改。A接完电话继续之前的修改。这时，如果没有一个很好地措施，文件最终的结果将很难预料。乐观锁和悲观锁这两个兄弟这时拍拍胸脯说，让我来帮你解决吧。&lt;/p&gt;

&lt;h3 id=&quot;悲观锁&quot;&gt;悲观锁&lt;/h3&gt;

&lt;p&gt;悲观锁说：我有一个防护罩（锁），谁拿到谁就能修改F，于是，A改文件F之前，先问悲观锁要防护罩，如果悲观锁告诉A防护罩已经给别人了，那么A必须等待，反之，如果防护罩空闲，A可以拿到防护罩，拿到之后，罩上文件F（加完锁），A就可以放心大胆的区修改文件F了，因为这时候在防护罩里F被A独享，A可以想什么时候修改完成就什么时候修改完成，随心所欲。但这样问题就产生了，防护罩只有一个，B没有办法及时拿到，没法对F修改，只能等待A修改完成之后，那么显然，并发性将会很差。
想象一下：你已经获得了对象A，但获得对象B之前你不想放弃对象A；但是另一个已经获得了对象B的用户，在获得对象A之前也不想放弃对象B。那么这时候就需要用到超时设置，它可以打破死锁和处理释放锁失败的情况。悲观锁很容易导致死锁的发生。
注：Synchronized互斥锁属于悲观锁。&lt;/p&gt;

&lt;h3 id=&quot;乐观锁&quot;&gt;乐观锁&lt;/h3&gt;
&lt;p&gt;乐观锁说：只有得到我给的口令的人才能对文件F进行修改，于是A，B纷纷想乐观锁要口令，得到口令后，AB都高兴得对文件F修改，由于A中途接电话，修改好的时间比B晚。B提前修改好之后，和乐观锁对对口令，乐观锁发现，哎，口令一致，允许修改。同时乐观锁为了保证一致性，选择保留B的劳动成果，把口令换了，等了一会，A也修改完成了，同样和乐观锁对对口令，发现哎口令不对，修改无效。
但这将会有一个问题，就是如果有很多人同时想对F修改，最终将只有一个人修改成功，其他人还得重试，这时候效率反而会很低。&lt;/p&gt;

&lt;p&gt;可以看一下java中原子增是怎么实现的。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

       &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

       &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getAndIncrement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

               &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

                   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

                   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compareAndSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;

                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

               &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但乐观锁同时也有一些缺点：&lt;/p&gt;

&lt;p&gt;①  观锁只能保证一个共享变量的原子操作。如上例子，自旋过程中只能保证value变量的原子性，这时如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。&lt;/p&gt;

&lt;p&gt;②  长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。&lt;/p&gt;

&lt;p&gt;③  ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://4loc.wordpress.com/2009/04/25/optimistic-vs-pessimistic-locking/&quot;&gt;一个更加有趣的例子&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 10 Jul 2015 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/10/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/10/%E6%82%B2%E8%A7%82%E9%94%81%E4%B9%90%E8%A7%82%E9%94%81.html</guid>
        
        
      </item>
    
      <item>
        <title>利用sublime快速编写markdown</title>
        <description>&lt;p&gt;插件实现插入带时间功能的说明：&lt;/p&gt;

&lt;h2 id=&quot;创建插件&quot;&gt;创建插件：&lt;/h2&gt;

&lt;p&gt;Tools → New Plugin:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sublime_plugin&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;addInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sublime_plugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;insert_snippet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;contents&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;---&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#you have to start with contents&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; layout:      post&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; title:      &quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; subtitle:      &quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; author:      stillwater&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; dateTime:  &quot;&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strftime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Y-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;m-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;H:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;M:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;S&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot; description: Description&quot;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;---&quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;保存为Sublime Text 2\Packages\User\ addInfo.py&lt;/p&gt;

&lt;!-- more --&gt;
&lt;p&gt;####2. 创建快捷键：&lt;/p&gt;

&lt;p&gt;Preference → Key Bindings - User:&lt;/p&gt;
&lt;pre&gt;
[
    {
        &quot;command&quot;: &quot;add_info&quot;,
        &quot;keys&quot;: [
            &quot;ctrl+shift+,&quot;#注意这里我试了一些字母而非标点，貌似没有作用，有可能是因为冲突，没有细究。
        ]
    }
]
&lt;/pre&gt;
</description>
        <pubDate>Mon, 29 Jun 2015 05:08:30 +0800</pubDate>
        <link>http://localhost:4000/2015/06/29/%E5%88%A9%E7%94%A8sublime%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99markdown.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/29/%E5%88%A9%E7%94%A8sublime%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99markdown.html</guid>
        
        
      </item>
    
      <item>
        <title>jekyll read more without plugins</title>
        <description>&lt;h3 id=&quot;adding-support-for--tag-to-jekyll-without-plugins&quot;&gt;Adding support for &lt;!-- more --&gt; tag to Jekyll without plugins&lt;/h3&gt;

&lt;p&gt;Here’s a quick tip for an approach I’ve started using to split post content at a given point for displaying in an archive page, without using a plugin.&lt;/p&gt;

&lt;p&gt;Until recently the approach I took to creating a snippet of a post for my archive page just trimming the post.content to 300 characters in the following way:&lt;/p&gt;

&lt;p&gt;This worked well at first, but when I wrote posts that had very little text before a block of code at the start of the post, the post snippets didn’t look very good:
&lt;img src=&quot;https://blog.omgmog.net/images/by%20default%202013-08-23%20at%2015.33.41.png&quot; /&gt;
There are plugins to allow you to specify where to cut off the content for an excerpt, such as 
&lt;a href=&quot;https://gist.github.com/stympy/986665&quot;&gt;this plugin.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But that won’t work as Jekyll runs with safe: true on GitHub Pages.&lt;/p&gt;

&lt;p&gt;So a solution… Well, Jekyll supports the liquid filters split and first, so we can do the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;post.content&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;strong&amp;gt;Read&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;more&amp;lt;/strong&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;endif&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then if we include a &lt;!-- more --&gt; in our post at the point that we want to split, we’ll get the post to cut off the content at that point.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.omgmog.net/images/by%20default%202013-08-23%20at%2015.45.23.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So how does it work?&lt;/p&gt;

&lt;p&gt;The split filter&lt;/p&gt;

&lt;p&gt;The first step is to split the content at the &lt;!-- more --&gt; marker using the split filter. When we use split filter, it turns out post.content in to an array with two (or more) parts.
​  &lt;br /&gt;
    {% post.content | split:”&lt;!-- more --&gt;” %}
​&lt;/p&gt;

&lt;p&gt;So we go from:
​  &lt;br /&gt;
    post.content =&amp;gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur libero nibh, semper quis libero sed, molestie molestie nulla.

&amp;lt;!-- more --&amp;gt;

In in augue enim. Aenean fringilla accumsan augue, at convallis quam consequat nec.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then the second step is to use the first filter to just select the part of post.content that came before the &lt;!-- more --&gt; marker:
​  &lt;br /&gt;
    {% post.content | split:”&lt;!-- more --&gt;” | first %}&lt;/p&gt;

&lt;p&gt;Which gives us:
​  &lt;br /&gt;
    post.content =&amp;gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur libero nibh, semper quis libero sed, molestie molestie nulla.&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I also take the steps to strip_html and trim the text to 300 characters.&lt;/p&gt;

&lt;p&gt;Update: You can use Jekyll’s built in “excerpt” feature these days, by doing the following:&lt;/p&gt;

&lt;p&gt;Define your excerpt_separator in your _config.yml: excerpt_separator: “&lt;!-- more --&gt;”
Update the examples I provided before, to use post.excerpt:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;post.excerpt&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;amp;#37;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 28 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/28/preview-to-Jekyll-without-plugins.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/28/preview-to-Jekyll-without-plugins.html</guid>
        
        
      </item>
    
      <item>
        <title>bigtable 浅析</title>
        <description>&lt;h2 id=&quot;bigtable-浅析&quot;&gt;##bigtable 浅析&lt;/h2&gt;
&lt;p&gt;    Bigtable 是一个用来管理结构化数据的分布式存储系统，具有很好的伸缩性，能够在几千台应用服务器上处理PB数量级数据。谷歌有许多项目都把数据存储在Bigtable中，包括web indexing,Google Earth, and Google Finance. 这些应用对Bigtable的侧重点不同，但是他们都是海量数据和实时性的应用。尽管需求变化多端，Bigtable很好的提供了一个灵活多变，高性能额解决方案。&lt;/p&gt;
&lt;h3 id=&quot;1introduction&quot;&gt;1.INTRODUCTION&lt;/h3&gt;
&lt;p&gt;    在很多方面Bigtable都与数据库类似：他们有同样的实现策略。并行数据库和主存数据库都具有高伸缩性和高性能的特点。但是Bigtable提供了一种不同的接个口。Bigtable不支持完全的关系数据模型；相反，它给客户端提供了一种简单的数据模型，这种数据模型支持对数据分布和格式的动态控制，并且允许客户端推出底层存储中数据的分布特性。Bigtable的数据可以使用任意字符的行列进行索引，Bigtable也把数据当作不可解释的字符串（uninterpreted strings），尽管客户端常常把不同形式的结构化、半结构化的数据序列化形成这些字符。客户端可以控制通过进行选择模式控制数据的位置。最后一点，调整Bigtable的模式参数能让客户端动态控制是从内存还是硬盘提供数据。
 &lt;!-- more --&gt;&lt;/p&gt;
&lt;h3 id=&quot;2data-model&quot;&gt;2. DATA MODEL&lt;/h3&gt;
&lt;p&gt;    一个Bigtable 集群是一系列运行Bigtable软件的进程。每一个集群都有一组tables。Bigtable中的表是稀疏的、分布式、持久的多维有序map。其数据有三个维度：行、列、时间戳。
(row:string, column:string, time:int64) → string
    我们称由一个特定行键、列键、时间戳指定的部分为一个单元(cell)。多行组合起来形成负载平衡的基本单元，多列组合起来形成访问控制和资源分配的基本单元。&lt;/p&gt;

&lt;p&gt;  考虑这样一个具体的列子：一个大量网页和相关信息的集合，该集合会被大量不同的应用利用。假设我们称此表为Webtable。在Webtable中，URL为行键，网页的不同方面成为列键，存储网页的内容。时间戳指的是网页被获取的时间。如下图所示
 &lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094651-0e8286ecd46f45f39977ff7045bd5422.jpg&quot; alt=&quot;&quot; /&gt;
    Rows. Bigtable以行键的字典序存储数据，而表中的行键是任意的字符串（目前能达到64KB，尽管对于大部分用户来说10-100字节就够了）。单行数据的读写是串行的（无论该行数据有多少不同的列正被读或者写），这种设计使得客户端能够在对某行数据进行并行更新的时候很容易知道系统的行为。换句话说，行是Bigtable控制事务一致性的基本单元，也就是意味着他不支持跨行事务。
    具有连续键值的行组合成tablets，这是数据分布和负载平衡的基本单元。这样的好处是读取很少的行范围内的数是高效并且一般仅仅需要和少量的机器交互。客户端可以利用这个数据局部性实现高效的数据访问。例如：在Webtable中，相同域名的网页分成一组分布在相邻（contiguous）行，存储的时候把URL的主机部分逆向存储。maps.google.com/index.html会以com.google.maps/index.html作为键存储。把相同域名的网页临近存放使得某些域名和主机分析更加高效。
    Columns. 列键放在一起称为列家族，它是访问控制的基本单元。在一个列族中存放的数据通常是相同类型的。在数据用key存储之前必须显式创建列族。在列族创建完成之后，该族任意的列键都可以使用：数据可以在不影响表模式的前提下存储在这样的列键中。我们的想法是让不同列族数比较少（最多上百），并且这样的列族在操作过程中几本不会改变；这种限制控制了共享元数据的大小。但是其对列数是没有任何限制的。
    改变一个表模式可能会删掉所有的列族，在这种情况下，该族任意列键存储的数据都将被删掉。由于Bigtable并不支持跨行事务，如果数据被存储在多行，特定的列键被删除，其对应的数据可能不会被删掉。
    列键是用如下的语法命名的：族：标识符。列族的名字必须是可打印的，但是标识符没有限制。关于Webtable的一个列族例子是网页编写的语言。在语言族中我们仅使用一个列键和一个空的标识符来存储每个网页的语言ID。该表另一个有用的列族是anchor；该族中的每一个列键都代表一个anchor。标识符就是所指向网址的名字。单元（cell）则包含与链接相关的文本。
    访问控制以及磁盘内存分配调度都使在列族层次上的。在Webtable例子中，这些控制允许我们控制几种不同类型的应用：有些应用新增底层数据，有些则读取底层数据和创建新建的列族，有些仅仅允许访问已存在的数据（甚至由于隐私的原因，不允许访问所有存在的族的数据）&lt;/p&gt;

&lt;p&gt;    TimeStamps. 表中不同单元格可以包含同样数据的不同版本，版本是通过timestamp索引的。Bigtable的时间戳是64位整数。他们可以被Bigtable隐式赋值，这种情况是“实时的”，精确到毫秒级，或者可以被客户端显式赋值。应用程序必须产生唯一的时间戳来避免冲突。不同版本的单元格以降序存储，这样最新版本会被最先读取。
    为了简化版本管理，我们支持两个per-column-family 告诉Bigtable自动进行垃圾版本回收。客户端既可以选择保存最近的几个版本，也可以选择保存足够新的版本（例如，仅保存最近七天写入的）
    在Webtable例子中，我们可以把时间戳存储在扒取网页的内容中：这列意味着这些网页版本实际扒取的时间。上面描述的垃圾回收机制使得Bigtable仅保存每个网页的最近三个版本。&lt;/p&gt;

&lt;h3 id=&quot;3-api&quot;&gt;3. API&lt;/h3&gt;

&lt;p&gt;    Bigtable的API提供了创建和删除表和列族的函数。同样也提供了改变集群、表和列族元数据的函数，例如访问控制权限。
    客户端程序可以删除Bigtable中的值或者向Bigtable中写入数据，从单行中检索数据，或者对表中数据子集进行迭代。&lt;/p&gt;

&lt;p&gt;图2描述了C++代码使用RowMutation抽象进行一系列更新操作。（无关细节略去了）调用Apply执行对Webtable的原子操作：向www.cnn.com增加了一个anchor，同时删除了一个不同的anchor。&lt;/p&gt;

&lt;p&gt;    图3 描述了C++使用一个Scanner抽象对某一个特定row的所有anchor进行迭代。客户机可以在不同的列族进行迭代，不过也有一些机制来限制scan可以遍历的行、列、时间戳。例如：我们可以限制让scan仅仅扫描那些匹配正则表达式的列，或者对时间戳进行限制来选择。
    Bigtable支持不同的特性让用户能够以复杂多变的方式操作数据。首先，Bigtable支持单行事务，这个特性使得对单行数据可以执行原子的读写序列。Bigtable目前还不迟滞跨行事务，尽管其给客户机提供了一个接口可以跨行批量写入。第二，Bigtable允许单元格充当整数计数器。第三，Bigtable支持客户端提供的脚本在服务器地址空间中执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094749-fbb3aadf1bdb4cd494db36491d939e13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4building-blocks&quot;&gt;4. BUILDING BLOCKS&lt;/h3&gt;
&lt;p&gt;    Bigtable 是基于其他几个Google基本结构的。一个Bigtable集群通常在运行各种各样分布式应用程序的共享机器上运行。Bigtable依赖于谷歌的集群管理系统来调度任务，管理资源，监控机器状态，处理异常机器。Bigtable进程与其他应用程序进程共享机器。如图4所示，一个Bigtable服务器可能与MapReduce、应用服务器、GFS服务器等运行在同一个机器上。
&lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094819-4e0e8bbefbf44428bf8b08c2adbc8db6.jpg&quot; alt=&quot;&quot; /&gt;
    Bigtable 使用GFS来存储日志和数据文件。GFS是一个分布式文件系统，可以保存每个文件的多个备份以提高可靠性和易用性。
    Bigtable使用Google SSTable不变文件格式存储Bigtable数据文件。一个SSTable提供了一个持久的有序不变的从key到values的map。用户可以通过指定的key查找关联的value，也可以对指定的key范围内数据迭代。每一个SSTable都包含了连续的几个块（默认情况下，每个块64KB，但是大小是可以配置的）块索引（存放在SSTable的最后）是用来定位块的；当SStable打开时索引就被加载进内存。这样查询只需要一次磁盘寻道:首先通过对内存索引进行二分查找找到对应的块。根据实际情况，一个SSTable可以完全被映射到内存，从而在执行查找和扫描是无需访问硬盘。
    Bigtable依赖一个高易用性、持久化的分布式锁机制——Chubby。一个Chubby服务由五个活动的副本组成，其中一个被选为主要的用来处理请求。当大部分副本都处于运行状态并且相通信时Chubby处于活动状态，Chubby使用Paxos算法来保证在遇到问题时副本之间的一致性。Chubby还提供了一个由目录和小文件组成的名字空间。每一个目录或文件都可以当作锁，读写文件都是原子操作。Chubby客户端库都提供了对Chubby文件的一致映射。每一个Chubby客户端都和Chubby服务维持一个会话（session）.当客户端session不能够在到期之前续期就会失效，当session失效后，它将失去所有的锁。Chubby客户端可以对文件或目录注册一个回调函数以便在session超期或发生改变时接受通知。
    Bigtable的Chubby可以处理不同的任务：保证任何时候之多只有一个master；存储Bigtable数据的启动位置（见5.1）；寻找tablet服务器以及确定tablet服务器的死亡（见5.2）；存储Bigtable模式（见5.5）。如果Chubby服务在一段时间内不可用，Bigtable就会不可用&lt;/p&gt;
&lt;h3 id=&quot;5implementation&quot;&gt;5.IMPLEMENTATION&lt;/h3&gt;
&lt;p&gt;    Bigtable的实现主要包括三哥主要部分：一个链接到每个客户端的库，一个master服务器，许多tablet服务器。Tablet 服务器可动态添加到集群（或删除）以适应不同的负载。
    master服务器负责把tablets分配到tablet服务器上，检测tablet服务器的增加和超期，平衡tablet服务器负载，对GFS进行垃圾收集。此外，还能处理模式改变，例如列族的创建和删除。
    每一个tablet服务器都管理一组tablets(一般每个tablet服务器上有10-1000个tablets)。tablet服务器处理对该服务器上tablets的读写请求，也能够将特别大的tablets分成几个。
    像许多单master的分布式存储系统一样，客户端的数据不会移动到master上：客户端直接与tablet服务器进行读写交互。因为Bigtable客户端无需通过master知道tablet的位置信息，大部分client从来都不喝master交互。这样，在实际中，master的负载就会特别小。
    一个Bigtable集群存储了大量的tables。每一个表都由一组tablets构成，每一个tablet包含一个行范围内的数据。初始情况下，每个表仅包含一个tablet。随着表大小的增长，它会自动分裂成多个tablets，默认每个表可以达到1GB。
    尽管，我们的模型支持任意大小的数据，但是目前的Bigtable的实现还不能非常大的数据。下面的部分江介绍Bigtable实现的细节情况。&lt;/p&gt;
&lt;h4 id=&quot;51tablet-location&quot;&gt;5.1 Tablet Location&lt;/h4&gt;
&lt;p&gt;    我们使用一个类似于B+树的三层结构存储位置信息。第一层是存储在Chubby中的文件，该文件包含root tablet的位置信息。root tablet包含一个特殊METADATA table所有teblets的位置信息.每一个tablet包含许多用户tablets的位置信息。root tablet和其他tablet有所不同——从来不会分裂——这种特性使得tablet位置层次结构不会超过三层。
    METADATA表用一行存储一个tablet的位置信息，位置信息包括tablet表标识符的编码和末行号。每一个METADATA行大约占用1KB的内存。而每个METADATA表的上限是128MB，这样我们三层结构能够处理2^34的tablets。
    客户端库遍历位置层次结构定位tablets，并且缓存寻找到的tablet的位置。如果client不知道一个tablet的位置，或者它发现它缓存的信息是错误的，那么它将第贵的在位置层次结构中移动。如果客户端缓存是空的，这种寻找算法需要三次来回传递消息，包括一次从Chubby中读取。如果客户端缓存中的信息过时了，这中算法需要6次来回消息传递才能找到某一个tablet，由于过时的缓存项只有在miss的情况下才会发现。尽管tablet位置信息存储在内存中，无需GFS访问，我们通过客户端库预取tablet位置信息进一步减少这种通常情况下的开销：不管什么时候客户端读取METADATA表时多读取几个tablet的metadata。
    我们同样在METADATA表中存储了耳机信息，包括与每一个tablet相关的所有事件的日志（如服务器向其提供服务的时间）这种信息对调试和性能分析的作用是很大的。&lt;/p&gt;

&lt;h4 id=&quot;52tablet-assignment&quot;&gt;5.2 Tablet Assignment&lt;/h4&gt;
&lt;p&gt;        每一个tablet一次至多只能分配给一个tablet服务器。master服务器跟踪这些活动的tablet 服务器以及当前正被分配给tablet 服务器的tablet，包括违背分配的tablets.当一个tablet是未分配的，tablet server 有足够的空间容纳一个tablet，master就会通过向tablet server发送一个tablet装载请求给tablet分配服务器。分配只有在一个master的失效备援工作之前tablet装载请求还没有收到：因为tablet server 仅接受当前master的装载请求。因此当一个master服务器发送了一个装载请求，它可以假设这个tablet被赋给了某个tablet服务器知道该服务器死亡，或者该tablet服务器通知master它已经卸载了该tablet.
        Bigtable使用Chubby跟踪这些tablet服务器，当一个tablet服务器启动时，在一个特定的Chubby目录下，对一个唯一名字的文件创建一个排它锁。master监测此目录来发现tablet服务器。当tablet失去排它锁时，就会停止对其上的tablets提供服务。例如：网络中断可能导致服务器失去和Chubby的会话。tablet服务尝试重新获取一文件的排它锁只要它的文件依旧存在。如果它的文件不存在了，服务器将不能提供任何服务，它就会终结它自己。不论什么时候tablet服务器终止，它将尝试释放自己的锁，以便master可以更快的给它的tablets分配新的服务器。
        master负责检测tablet服务器不再向tablets提供服务的情形，尽可能快的重新分配这些tablets。为了检测一个tablet 服务器不再向tablet提供服务，master周期性询问每一个tablet服务器的锁的状态。如果某个tablet服务器告诉master它丢失了它的锁，或者master几经尝试都不能够到达一个tablet服务器.master就会尝试获取服务器文件排它锁。如果master能够获取该锁，这说明chubby正常并且tablet服务器要么终结了要么不能够到达Chubby.master将会通过删除它的服务器文件保证该tablet服务器永远都不能够再提供服务。一旦一个服务器文件被删除，master就会将之前分配给他的tablets重新变成未分配的。为了确保master和Chubby之间不易受到网络问题的影响，master终结自己当它与Chubby之间的会话插旗。master失败并不会影响tablets分配。
    当一个master被集群管理系统启动时，在改变tablet分配之前，它需要知道当前的tablet分配情况。在启动时，master会执行以下的步骤：
    （1）首先master会在Chubby中获取一个为一个master lock,此锁可以避免并行的master实例
    （2）master扫描Chubby的servers目录发现活动的tablet 服务器
    （3）master与每一个活动的tablet server交互发现那些tablets已经分配到每一个服务器，更新当前master所了解到的信息（任何之前masters发送的tablet装载请求都会被拒绝)
    （4）master扫描METADATA表知道有哪些tablets.不论什么时候扫描到一个没有被分配的tablet,master把这个tablet放到未分配tablet集合中，这样可以是得tablet分配更加方便。
        
        一个比较复杂的事情是只有当METADATA tablets已经被分配之后才能够扫描METADATA表。因此，在开始扫描之前（第四步），master把root tablet加到未分配tablet集合中如果在第三步中没有对root tablet进行分配。这会保证root tablet会被分配。因为root tablet包含所有的METADATA表的名字，master在扫描完root tablet之后就会知道所有的METADATA表的名字。
        这些tablets集合只有在表创建或删除的时候、俩个tablets合并成一个更大的tablet,或者一个tablet分裂成俩个更小的tablets时才会改变。master能够跟踪这些改变因为除了最后一个操作，其他操作都是由master初始化的。对于tablets分裂需要特殊对待，因为这个操作是由tablet servers启动的。tablet server 分裂过程是这样的，在METADATA表中记录新的tablet server的信息。在执行分裂之后，tablet server通知master.如果分裂通知丢失（由于tablet server或者master死亡）。master会发现该新的tablet当其要求tablet server加载已经分裂的tablet的时候。tablet server会告知master关于该分裂，因为master发现在METADATA表中的tablet项仅能描述它要求加载tablet的一部分信息。&lt;/p&gt;

&lt;h4 id=&quot;53tablet-serving&quot;&gt;5.3 Tablet Serving&lt;/h4&gt;
&lt;p&gt;        tablet的持久化信息被存储在GFS中，如图6所示&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images.cnitblog.com/blog/424079/201312/21094848-56256e5d4b4b4f8aa5088e027c5edd80.jpg&quot; alt=&quot;&quot; /&gt;
        更新信息都被提交到一个存储恢复记录的commit log中。最近提交的信息都被存储在内存中的一个叫做memtable的有序缓冲中。一个memtable保存了row-by-row basis的更新，每一行都通过写时复制来保证行层次的一致性。更早的更新存储在一系列的SSTables中（不可改变）
        为了恢复一个tablet，tablet server从METADATA表中读取元数据。这些元素据包括组成tablet和一系列的还原点的SSTables，这些元数据可能包含tablet数据的提交日志的指针。server把SSTables的索引读进内存，通过还原点中更新记录重构memetable。
        当tablet server接受到一个写操作请求，server检查该请求是否是良定义的，发送者是否有权限执行该操作。检查权限是通过Chubby文件中一个允许写的列表（该文件在CHubby客户端缓存中，几乎每次都能命中）。合法的改变都会写入到提交日志中。批量提交小的改变可以提高系统吞吐量。当写操作提交之后，内容就被插入到memtable总。
        当tablet server接收到一个读操作时，同样先检查其形式和权限。
        当tablets正在分裂或者合并的时候读写操作仍然可以继续。当tablets在被压缩时，读写操作仍然可以进行。&lt;/p&gt;
&lt;h4 id=&quot;54compactions&quot;&gt;5.4 Compactions&lt;/h4&gt;
&lt;p&gt;        当执行写操作时，memtable大小增加。当memtable大小达到阈值时memtable就会被冻结，一个新的memtable会被创建，冻结的memtable会被转换成SSTable并被写入到GFS中。这种小型压缩过程有两个目的：减少tablet server的内存消耗，减少在server死亡情况下恢复过程中需要从commit log中读取的数据量
        每一次微小压缩（minor compaction）都会创建一个新的SSTable。如果这种行为不受约束，读操作可能需要合并任意数量的SSTable中的更新记录。相反，如果我们限制了这些文件的数目通过在后台周期性执行一个合并压缩。合并压缩读取几个SSTable和memtable的内容，写入到一个新的SStable中。当压缩完成后，输入SSTables和memtable可以被丢弃掉。
        把所有SSTables中的内容写入到一个SSTable的合并操作称之为大的合并。由小型压缩产生的SSTables可以包含特殊的删除项，该删除项可以限制在比较老的SStable中仍然存活着的数据。另一方面，大的压缩产生的SSTable不包含任何删除信息或数据。Bigtable周期性的检测所有的tablets并且周期性应用大的压缩。这些大的压缩让Bigtable回首被删除数据使用的水资源，同时也能保证让需删除的数据机试从系统中小时，这一点对于存储敏感数据的服务很重要。
        Bigtable读性能得以与GFS的局部性优化。当文件被写入时，GFS尝试把数据的副本放在写者的机器上。当读取GFS文件时，读取的数据来源于最近可用的副本中。因此，在tablet servers与GFS servers共享机器时，tablet servers会压缩到在硬盘上有副本的SStables中，这样可以在处理连续的读请求时快速访问这些SSTables&lt;/p&gt;

&lt;h4 id=&quot;55模式管理&quot;&gt;5.5模式管理&lt;/h4&gt;
&lt;p&gt;        BigTable的模式存储在Chubby中。Chubby给Bigtable模式提供了一个搞笑的交流基质，它提供了对整个文件原子写操作和小文件的一致性缓存。列入，假设一个客户端程序想要删除表中的某些列族。master执行访问控制检查，验证结果模式是梁定义的，然后向Chubby中重写相应的模式来安装新的模式。不论什么时候tablet servers需要决定那些列族存在，仅需要读取Chubby中相应的模式，这在Chubby的客户端缓存中常常是存在的。因为Chubby缓存是一致的，tablet servers 一定能够看到对那个文件的所有改变。&lt;/p&gt;

&lt;p&gt;        参考资料：
　　　　Bigtable: A Distributed Storage System for Structured Data&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/28/(%E8%AF%91)bigtable%E6%B5%85%E6%9E%90.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/28/(%E8%AF%91)bigtable%E6%B5%85%E6%9E%90.html</guid>
        
        
      </item>
    
      <item>
        <title>github搭建个人博客</title>
        <description>&lt;h3 id=&quot;githubmarkdownjekyll-搭建个人博客&quot;&gt;GitHub+Markdown+Jekyll 搭建个人博客&lt;/h3&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;首先以下所有内容都是针对mac的，不同系统装的软件差不多，但过程千差万别，如果是其他系统凉快去。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;&lt;em&gt;准备工作&lt;/em&gt;：&lt;/h3&gt;
&lt;p&gt;mac中自带git和gem.这两者就不用安装了，gem是一种文件组织的包，一般的ruby的很多插件都有由这种各种的包提供。安装Jekyll需要它的支持。&lt;/p&gt;
&lt;h4 id=&quot;安装jekyll&quot;&gt;&lt;em&gt;安装jekyll&lt;/em&gt;&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gem update —system
$ sudo gem install jekyll 注意需要sudo，否则 no permission. 直接运行以上命令会出现一些错误。运行以下命令
$ gem sources -l 可以看到终端显示 \*\*\* CURRENT SOURCES \*\*\*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;https://rubygems.org
可见gem的源默认是https://rubygems.org/，
所以首先更换gem源，换源之前首先删除旧源
	$ gem sources –remove https://rubygems.org
注意不要多字符或少字符，不然会出现
source https://rubygems.org not present in cache 
remove前是—，否则会
source emove not present in cache&lt;/p&gt;

&lt;h4 id=&quot;添加新源&quot;&gt;&lt;em&gt;添加新源&lt;/em&gt;&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem sources -a https://ruby.taobao.org/ 这是一个完整 rubygems.org 镜像，你可以用此代替官方版本，同步频率目前为15分钟一次以保证尽量与官方服务同步。 添加完成之后查看一下是否更换成功

$ gem sources -l &amp;lt;!-- more --&amp;gt; 更换markdown模板解释器 安装模板,默认的模板是Maruku,我们替 换为RDiscount。 
$ sudo gem install rdiscount Maruku是纯ruby写的Markdown模板解释 器。 RDiscount是C写的模板解释器。速度快上很多。 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完jekyll之后，我们需要创建网站的各种目录结构和源文件。由于这些文件最终在github中管理，如何利用github创建网站可以看github pages.这里直接直接将整个过程融入一个完整blog的构建过程。
让github管理本地文件有两种方式：
由于github托管的网站必须是username.github.io,对应的仓库也是username.github.io
1.首先git clone username.github.io到本地，会在本地创建一个 username.github.io文件夹，cd进去一看是空的，输入命令ls -a可以发现有一个.git文件，这个文件联系起了本地和远程git服务器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone git@username.github.io.git
$ cd username.github.io
$ jekyll new blog
$ cd blog
$ jekyll serve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.可以事先在本地创建完blog之后，在创建git文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll new blog
$ cd blog
$ git init git init会在本地创建一个.git文件,Initialized empty Git repository in yourPath/.git/

$ git add */git add —all
$ git commit -m “commit”
$ git remote add origin 
git@git@username.github.io.git (若是第一次提交该项目的文件或是修改项目文件名后则需要这行这个命令，以后就可不用执行该命令)

git push -u origin master 如果之前已经 add origin，则会报出如下错误： fatal: remote origin already exists. 解决方法：

git remote set-url origin git@git@username.github.io.git 这将替换之前添加的orgin。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时访问username.github.io，将会看到你刚刚创建的网站。
可以看到Jekyll目录结构&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–_config.yml&amp;gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_drafts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–articles1.textile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–articles2.md&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_includes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–footer.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–header.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_layouts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–default.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–post.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_posts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–2014-06-17-articles1.textile&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–2014-06-17-articles1.md&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–_site&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–index.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–other files&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;_config.yml :保存配置数据。 
_drafts :存放未发布的文章。&lt;br /&gt;
_includes :存放页面片段,即页头 ( head.html )、页脚&lt;br /&gt;
( footer.html )、导航&lt;br /&gt;
( navigation.html )、评论 
( disqus_comments.html )等,这些 资源通过标签添加到index.html中,从而形 成一个完整的页面。 
_layouts :存放模板文件。文章模板、 关于页面模板、首页模板等。 
_posts :存放文章的文件。并且文章文 件名称要符合 YEAR-MONTH-DAY- title.MARKUP 格式。 
_site :经过jekyll转换的页面。 
index.html :网站首页。 
other files :其他文件,存放css、 js、image等。&lt;/p&gt;

&lt;p&gt;Jekyll解析流程 
首先会加载_posts及文件夹下的所有文章, 将其参数和文章内容组织保存在内存中,所 有的文章的内容、参数都在site.posts对象 (其他文件夹下的文章不会放入site.posts 中)。 
其次加载_layouts文件夹下的所有模板。 再次加载_includes文件夹下的所有需要被引入的内容。 
最后根据每一篇需要编译的文章选择的其参 数定义的模板来创建一个模板,并将当前文 章的内容、参数等进行扩展后放在page对 象、content对象中,然后进行模板的编 译,生成html文件,并按照一定规则放在 _site文件夹下。也就是说在创建一篇文章 时,其实所有文章的内容都已经被读取出来 了,这也为文章相互之间的关联提供了可 能。&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2015 22:00:44 +0800</pubDate>
        <link>http://localhost:4000/2015/06/27/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/27/github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</guid>
        
        
      </item>
    
      <item>
        <title>JS变量初始化过程</title>
        <description>&lt;h1 id=&quot;js变量初始化过程&quot;&gt;JS变量初始化过程&lt;/h1&gt;

&lt;h2 id=&quot;顶级变量初始化&quot;&gt;顶级变量初始化&lt;/h2&gt;

&lt;h2 id=&quot;函数变量&quot;&gt;函数变量&lt;/h2&gt;

&lt;h2 id=&quot;没有scope的块&quot;&gt;没有scope的块&lt;/h2&gt;

&lt;p&gt;JavaScript函数与变量机制与大部分语言完全不同，在JS中，所有的局部变量和函数都是特定内部对象的属性，即LexicalEnvironment（LE）&lt;/p&gt;

&lt;p&gt;在浏览器中顶级的LE是window对象，也叫做全局变量&lt;/p&gt;

&lt;h2 id=&quot;顶级变量初始化-1&quot;&gt;顶级变量初始化&lt;/h2&gt;

&lt;p&gt;当js即将执行时，有一个预处理阶段叫做变量实例化&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，解释器扫描Function Declarations,也就是function name{},解释器将对每个声明创建一个函数并作为Window的一个变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'f:'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'g:'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;此时，浏览器发现函数f,于是创建Function，将其存为window.f:
&lt;!-- more --&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 1. Function Declarations are initialized before the code is executed.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// so, prior to first line we have: window = { f: function }&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'f:'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- FunctionDeclaration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'g:'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　而这也导致，f可以在声明之前调用
　　&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
	f()
	function f() { alert('ok') }
	​&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;解释器扫描var declarations,作为window的属性。但是此时变量并没有被赋值，所有的变量此时都是undefined。
// 1. Function declarations are initialized before the code is executed.
// window = { f: function }
// 2. Variables are added as window properties.
// window = { f: function, a: undefined, g: undefined }&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- var&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'f:'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'g:'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;-- var&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　虽然g是一个函数表达式，但是解释器不关心这些，只要使用var声明，都会在此阶段处理,这也导致变量不能和函数同名&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.FunctionDeclarations become ready-to-use functions. That allows to call a function before it’s declaration.&lt;/p&gt;

  &lt;p&gt;2.Variables start as undefined.&lt;/p&gt;

  &lt;p&gt;3.All assignments happen later, when the execution reaches them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;代码执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　当变量活函数被访问时，解释器从window中获取&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true, because window.a exists&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined, because assignment happens below&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// function, because it is Function Declaration&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined, because assignment happens below&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;  
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;赋值过后，a=5,g成为了函数，注意下面代码的区别：
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;  
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;　如果变量声明时未用var,那么在初始化时就不会被创建（或者说成为window的属性）,解释器看不到的：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false, there is no window.b&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// error, b is not defined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;但赋值之后，&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;成为&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的全局变量：&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; 
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true, there is window.b = 5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;考虑一下：下面代码的执行结果：&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// window = {a:undefined}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;​```&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;javascript&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The answer is “Error: no such variable”, because there is no variable a at the time of “a” in window check.&lt;/p&gt;

&lt;p&gt;So, the if branch does not execute and there is no a at the time of alert.&lt;/p&gt;

&lt;h2 id=&quot;函数变量-1&quot;&gt;函数变量&lt;/h2&gt;

&lt;p&gt;当函数执行时，每一个函数调用都会产生新的包含参数、变量、嵌套函数声明的LexicalEnvironment&lt;/p&gt;

&lt;p&gt;变量是内部用来读写变量的，和window不同，函数的LexicalEnvironment 是不能直接访问的&lt;/p&gt;

&lt;p&gt;下面我们看一下函数执行的细节：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;phrase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;phrase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;1.在解释器开始执行函数代码时，会创建一个填充参数、局部变量、嵌套函数的LexicalEnvironment ，很显然参数具有初始值，而局部变量则是未定义的&lt;/p&gt;

&lt;p&gt;　　2.函数代码开始执行，最后执行赋值语句。内部的变量赋值意味着LexicalEnvironment相应的属性获得了新值&lt;/p&gt;

&lt;p&gt;so，phrase=”Hi, “+name 改变了LexicalEnvironment&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sayHi(name) {
// LexicalEnvironment = { name: 'John', phrase: undefined }
  var phrase = &quot;Hi, &quot; + name
// LexicalEnvironment = { name: 'John', phrase: 'Hi, John'}
  alert(phrase)
}
sayHi('John')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最后一行alert(phrase)从LexicalEnvironment 搜获phrase&lt;/p&gt;

&lt;p&gt;　　3.函数执行之后，LexicalEnvironment会废弃他的内容，因为这些变量不再需要，但是情况并不总是这样：
　　&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Specification peculiarities
If we look into the recent ECMA-262 specification, there are actually two objects.&lt;/p&gt;

  &lt;p&gt;The first is a VariableEnvironment object, which is actually populated by variables and functions, declared by FunctionDeclaration, and then becomes immutable.&lt;/p&gt;

  &lt;p&gt;The second is a LexicalEnvironment object, which is almost same as VariableEnvironment, but it is actually used during the execution.&lt;/p&gt;

  &lt;p&gt;A more formal description can be found in the ECMA-262 standard, sections 10.2-10.5 and 13.&lt;/p&gt;

  &lt;p&gt;It is also noted that in JavaScript implementations, these two objects can be merged into one. So, we evade irrelevant details and use the term LexicalEnvironment everywhere.
　　&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;没有scope的块-1&quot;&gt;没有scope的块&lt;/h2&gt;

&lt;p&gt;下面的代码没有任何区别&lt;/p&gt;

&lt;p&gt;​```javascript
var i = 1
{
  i = 5
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;​```javascript
i = 1
{
  var i = 5
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;所有的变量声明在块执行之前就已经初始化&lt;/p&gt;

&lt;p&gt;这一点和Java、C++不用，在JS中，变量在循环之后依旧存在，因为他们的scope是函数&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5, variable survives and keeps value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在循环中声明变量很方便，但不要认为循环之后变量就不存在了，不要把循环当作其scope&lt;/p&gt;

&lt;p&gt;下面的代码的结果是什么：&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;var指令在预处理阶段就执行了&lt;/p&gt;

&lt;p&gt;因此，window在alert之前成了局部变量&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;LexicalEnvironment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;所以当执行到第一行时，变量window存在但是未定义&lt;/p&gt;

</description>
        <pubDate>Mon, 26 Aug 2013 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2013/08/26/JS%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/2013/08/26/JS%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html</guid>
        
        
      </item>
    
      <item>
        <title>（转）使用 PNG 图片制作动态 Loading</title>
        <description>&lt;p&gt;曾经遇到过在一个 GIF 图片里面制作一个半透明的 Loading，无论怎么折腾，总有锯齿，非常不好处理。最后无奈地使用了非半透明的“菊花”，视觉有所降级。&lt;/p&gt;

&lt;p&gt;其实如果不兼容 IE 的话，还是可以使用 CSS3 + PNG 图片完成这个动态的 GIF Loading 的。具体效果见 &lt;a href=&quot;http://pizn.github.io/demo/loading.html&quot; target=&quot;_blank&quot; title=&quot;demo&quot;&gt;DEMO&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;实现的方法和代码如下：&lt;/p&gt;

&lt;pre name=&quot;colorcode&quot; class=&quot;css&quot;&gt;
#loading {
     width: 36px;
     height: 36px;
     position: absolute;
     top: 50%;
     left: 50%;
     margin: -18px 0 0 -18px;
     text-indent: -9999em;
     overflow: hidden;
     /** loading 图片地址 **/
     background: url(loading.png) no-repeat 0 0;
     /** webkit **/
     -webkit-animation-name: loadRotate;
     -webkit-animation-duration: 1s;
     -webkit-animation-iteration-count: infinite;
     -webkit-animation-timing-function: linear;
     /** firefox **/ 
     -moz-animation-name: loadRotate;
     -moz-animation-duration: 1s;
     -moz-animation-iteration-count: infinite;
     -moz-animation-timing-function: linear;
     /** w3c **/
     animation-name: loadRotate;
     animation-duration: 1s;
     animation-iteration-count: infinite;
     animation-timing-function: linear;
 }
 /** webkit **/
 @-webkit-keyframes loadRotate {
     from {
         -webkit-transform:rotate(0deg);
     }
     25% {

     }
     to {
         -webkit-transform:rotate(360deg);
     }
 }
 /** firefox **/
 @-moz-keyframes loadRotate {
     from {
         -moz-transform:rotate(0deg);
     }
     to {
         -moz-transform:rotate(360deg);
     }

 }
 /** w3c **/
 @keyframes loadRotate {
     form {
         transform: rotate(0deg);
     }
     to {
         transform: rotate(360deg);
     }
 }
&lt;/pre&gt;

&lt;p&gt;HTML 代码如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot; name=&quot;colorcode&quot;&gt;
&amp;lt;p id=&quot;loading&quot;&amp;gt;Loading&amp;lt;/p&amp;gt;
&lt;/pre&gt;

&lt;p&gt;恩，这样就 OK 了。&lt;/p&gt;

&lt;p&gt;后话：Loading 的“菊花”样式，有一个 JS 可以实现，就是 &lt;a href=&quot;http://fgnass.github.com/spin.js/&quot; title=&quot;spin.js&quot; target=&quot;_blank&quot;&gt;spin.js&lt;/a&gt;，也能兼容 IE 。但其兼容 IE 的方式是使用滤镜，对性能有所影响。&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Oct 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2012/10/26/PNG-Loading.html</link>
        <guid isPermaLink="true">http://localhost:4000/2012/10/26/PNG-Loading.html</guid>
        
        
      </item>
    
  </channel>
</rss>
