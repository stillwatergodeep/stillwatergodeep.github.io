---
 layout:      post
 title:      "数据库悲观锁乐观锁1"
 subtitle:      
 author:      stillwater
 date:  2017-01-02 16:00
 description: "什么是数据库悲观锁、乐观锁，如何用"
---




悲观锁&乐观锁
悲观锁与乐观锁是并发访问资源解决冲突不一致的常用的方式，本文将就这两种锁的特点进行讨论。
悲观锁：顾名思义，它对事物持消极态度，它假设他要修改的数据如果不加锁的话会被别人修改，所以它每次操作前先独占锁。悲观者的人生观是一件事情我必须要百分之百完全控制才会去做，否则就认为这件事情一定会出问题；
而乐观者的人生观则相反，凡事不管最终结果如何，他都会先尝试去做，大不了最后不成功。
这就是悲观锁与乐观锁的区别，悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据

现在大家很多东西都放在云上面，云上面有一个很不错的功能：云协作。假设有这么一个场景，有一个协作群，群中有两个用户，A&B，其中有一个共享文件F.A看到文件中有一处出错，想去修改它，修改到一半，突然接到一个电话，这时候B也发现F文件中有一个错误，也想去修正，于是也尝试这区修改。A接完电话继续之前的修改。这时，如果没有一个很好地措施，文件最终的结果将很难预料。乐观锁和悲观锁这两个兄弟这时拍拍胸脯说，让我来帮你解决吧。

### 悲观锁

悲观锁说：我有一个防护罩（锁），谁拿到谁就能修改F，于是，A改文件F之前，先问悲观锁要防护罩，如果悲观锁告诉A防护罩已经给别人了，那么A必须等待，反之，如果防护罩空闲，A可以拿到防护罩，拿到之后，罩上文件F（加完锁），A就可以放心大胆的区修改文件F了，因为这时候在防护罩里F被A独享，A可以想什么时候修改完成就什么时候修改完成，随心所欲。但这样问题就产生了，防护罩只有一个，B没有办法及时拿到，没法对F修改，只能等待A修改完成之后，那么显然，并发性将会很差。
想象一下：你已经获得了对象A，但获得对象B之前你不想放弃对象A；但是另一个已经获得了对象B的用户，在获得对象A之前也不想放弃对象B。那么这时候就需要用到超时设置，它可以打破死锁和处理释放锁失败的情况。悲观锁很容易导致死锁的发生。
注：Synchronized互斥锁属于悲观锁。

### 乐观锁
乐观锁说：只有得到我给的口令的人才能对文件F进行修改，于是A，B纷纷想乐观锁要口令，得到口令后，AB都高兴得对文件F修改，由于A中途接电话，修改好的时间比B晚。B提前修改好之后，和乐观锁对对口令，乐观锁发现，哎，口令一致，允许修改。同时乐观锁为了保证一致性，选择保留B的劳动成果，把口令换了，等了一会，A也修改完成了，同样和乐观锁对对口令，发现哎口令不对，修改无效。
但这将会有一个问题，就是如果有很多人同时想对F修改，最终将只有一个人修改成功，其他人还得重试，这时候效率反而会很低。

可以看一下java中原子增是怎么实现的。



```java
    public class AtomicInt {

       private volatile int value;

       public final int get() {

           return value;

        }
  
        public final int getAndIncrement() {

               for (;;) {

                   int current = get();

                   int next = current + 1;

                   if (compareAndSet(current, next))

                        return current;

               }

            }
```

但乐观锁同时也有一些缺点：

①  观锁只能保证一个共享变量的原子操作。如上例子，自旋过程中只能保证value变量的原子性，这时如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。

②  长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。

③  ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。

[一个更加有趣的例子](https://4loc.wordpress.com/2009/04/25/optimistic-vs-pessimistic-locking/)


